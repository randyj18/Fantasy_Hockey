<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Hockey Draftcentre</title>
    <style>
        /* --- General Styles --- */
        :root {
            --primary-color: #003366;
            --secondary-color: #0055a4;
            /* Slightly lighter blue */
            --accent-color: #ffd700;
            /* Gold */
            --light-bg: #f8f9fa;
            --dark-text: #212529;
            --light-text: #f8f9fa;
            --border-color: #dee2e6;
            --hover-bg: #e9ecef;
            --success-bg: #d1e7dd;
            --success-border: #a3cfbb;
            --info-bg: #cff4fc;
            --info-border: #9eeaf9;
            --drafted-bg: #e9ecef;
            --drafted-text: #6c757d;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            /* Remove body padding */
            background-color: var(--light-bg);
            color: var(--dark-text);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .container {
            max-width: 1300px;
            /* Wider container */
            margin: 0 auto;
            padding: 15px;
            /* Consistent padding */
            width: 100%;
            box-sizing: border-box;
            /* Include padding in width */
            flex-grow: 1;
            /* Allow container to grow */
        }

        h1,
        h2 {
            color: var(--primary-color);
            margin-bottom: 1rem;
            margin-top: 1.5rem;
            /* Add top margin */
        }

        h1 {
            font-size: 2rem;
        }

        h2 {
            font-size: 1.5rem;
        }

        /* --- Buttons & Inputs --- */
        button,
        input,
        select,
        .btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            font-size: 0.9rem;
            margin-right: 0.5rem;
            /* Reduced margin */
            margin-bottom: 0.5rem;
            /* Add bottom margin for wrapping */
            background-color: #fff;
            transition: all 0.2s ease-in-out;
            vertical-align: middle;
            /* Align items better */
        }

        input[type="text"],
        input[type="password"] {
            width: 200px;
            /* Default width */
            max-width: 100%;
            /* Allow shrinking */
        }

        select {
            min-width: 150px;
        }

        button,
        .btn {
            cursor: pointer;
            background-color: var(--primary-color);
            color: var(--light-text);
            border-color: var(--primary-color);
        }

        button:hover,
        .btn:hover {
            background-color: var(--secondary-color);
            border-color: var(--secondary-color);
        }

        button:disabled,
        .btn:disabled {
            background-color: #cccccc;
            border-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .btn.secondary {
            background-color: #6c757d;
            border-color: #6c757d;
        }

        .btn.secondary:hover {
            background-color: #5a6268;
            border-color: #545b62;
        }

        .btn.danger {
            background-color: #dc3545;
            border-color: #dc3545;
        }

        .btn.danger:hover {
            background-color: #c82333;
            border-color: #bd2130;
        }

        a.btn {
            /* Style links as buttons */
            text-decoration: none;
            display: inline-block;
        }

        /* --- Layout Sections --- */
        .auth-container {
            background-color: #fff;
            padding: 1rem 15px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin-bottom: 1rem;
        }

        #auth-status {
            margin: 0.5rem 0 0 0;
            font-style: italic;
            color: #6c757d;
        }

        .league-info {
            background-color: #fff;
            padding: 0.75rem 1rem;
            border-radius: 0.25rem;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border-color);
            flex-wrap: wrap;
            /* Allow wrapping on small screens */
            gap: 10px;
        }

        .league-name {
            font-weight: bold;
            font-size: 1.2rem;
            color: var(--primary-color);
        }

        .league-details {
            color: #6c757d;
            font-size: 0.9rem;
        }

        .league-selection-area {
            background-color: #fff;
            padding: 1rem;
            border-radius: 0.25rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
        }

        .draft-area {
            display: grid;
            grid-template-columns: 1fr;
            /* Default single column */
            gap: 1.5rem;
        }

        /* Grid layout for larger screens */
        @media (min-width: 992px) {
            .draft-area {
                grid-template-columns: repeat(2, 1fr);
                /* Two columns */
            }

            .available-players-section {
                grid-column: 1 / 2;
                /* Span first column */
            }

            .drafted-players-section {
                grid-column: 2 / 3;
                /* Span second column */
            }

            .full-width-section {
                grid-column: 1 / -1;
                /* Span both columns */
            }
        }

        .card {
            /* Card styling for sections */
            background-color: #fff;
            padding: 1rem;
            border-radius: 0.25rem;
            border: 1px solid var(--border-color);
            margin-bottom: 1rem;
            /* Space below cards */
        }

        .controls-section,
        .status-section,
        .action-buttons {
            grid-column: 1 / -1;
            /* Span full width */
        }

        /* --- Controls & Filters --- */
        .controls-section .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            /* Responsive grid */
            gap: 1rem;
            align-items: center;
        }

        .search-container,
        .position-filter-container,
        .view-options-container {
            margin-bottom: 0;
            /* Remove bottom margin as grid handles gap */
        }

        #searchInput {
            width: 100%;
            box-sizing: border-box;
        }

        /* Full width search */

        .position-filter {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .position-filter button {
            padding: 0.3rem 0.6rem;
            font-size: 0.85rem;
            background-color: var(--light-bg);
            border-color: var(--border-color);
            color: var(--dark-text);
        }

        .position-filter button:hover {
            background-color: var(--hover-bg);
        }

        .position-filter button.active {
            background-color: var(--primary-color);
            color: var(--light-text);
            border-color: var(--primary-color);
        }

        .view-options-container label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        input[type="checkbox"] {
            margin-right: 5px;
        }

        .drafted-team-filter {
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            /* Wrap on small screens */
        }

        /* Commissioner Toggle */
        .commissioner-controls {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background-color: #fff3cd;
            /* Light yellow */
            border: 1px solid #ffeeba;
            border-radius: 0.25rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .commissioner-controls strong {
            color: #856404;
        }

        .commish-toggle-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .commish-toggle-container label {
            font-weight: normal;
            cursor: pointer;
        }

        /* Basic Toggle Switch Style */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            /* Smaller switch */
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--primary-color);
        }

        input:focus+.slider {
            box-shadow: 0 0 1px var(--primary-color);
        }

        input:checked+.slider:before {
            transform: translateX(20px);
        }

        /* --- Tables --- */
        .table-container {
            overflow-x: auto;
            /* Horizontal scroll on small screens */
            max-height: 450px;
            /* Max height */
            overflow-y: auto;
            /* Vertical scroll */
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            background-color: #fff;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 0;
            /* Remove bottom margin */
        }

        th,
        td {
            padding: 0.6rem 0.75rem;
            /* Adjusted padding */
            border: none;
            /* Remove cell borders */
            border-bottom: 1px solid var(--border-color);
            /* Use bottom border */
            text-align: left;
            font-size: 0.85rem;
            /* Slightly smaller font */
            white-space: nowrap;
            /* Prevent text wrapping */
        }

        th {
            background-color: var(--light-bg);
            position: sticky;
            top: 0;
            cursor: pointer;
            font-weight: 600;
            /* Bolder headers */
            z-index: 1;
            /* Keep header above scrolling content */
        }

        th:hover {
            background-color: var(--hover-bg);
        }

        tbody tr:last-child td {
            border-bottom: none;
        }

        /* Remove border on last row */
        tbody tr:hover {
            background-color: var(--hover-bg);
        }

        th.sorted-asc::after {
            content: " ▲";
            font-size: 0.8em;
        }

        th.sorted-desc::after {
            content: " ▼";
            font-size: 0.8em;
        }

        tr.drafted {
            background-color: var(--drafted-bg) !important;
            /* Use !important if needed */
            color: var(--drafted-text);
        }

        tr.drafted .draft-button {
            /* Hide draft button on drafted rows */
            visibility: hidden;
        }

        tr.drafted td {
            text-decoration: line-through;
        }

        td .draft-button,
        td .remove-button {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
        }

        td .remove-button {
            background-color: #dc3545;
            border-color: #dc3545;
            color: white;
        }

        td .remove-button:hover {
            background-color: #c82333;
            border-color: #bd2130;
        }

        /* --- Current Drafter & Status --- */
        .status-section {
            display: flex;
            justify-content: space-between;
            /* Align items */
            align-items: center;
            flex-wrap: wrap;
            /* Wrap on small screens */
            gap: 1rem;
        }

        .current-drafter {
            background-color: var(--info-bg);
            border-left: 4px solid var(--info-border);
            padding: 0.75rem 1rem;
            border-radius: 0.25rem;
            font-size: 0.95rem;
            flex-grow: 1;
            /* Allow it to take available space */
            margin-bottom: 0;
            /* Remove bottom margin */
        }

        .current-drafter.my-turn {
            background-color: var(--success-bg);
            border-left-color: var(--success-border);
        }

        .current-drafter p {
            margin: 0;
        }

        #start-draft-btn,
        #bank-pick-btn {
            margin-bottom: 0;
        }

        /* Align with status */
        .draft-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #bank-pick-btn {
            background-color: #795548;
            /* Brown color to differentiate */
            border-color: #5d4037;
        }

        #bank-pick-btn:hover {
            background-color: #6d4c41;
            border-color: #5d4037;
        }


        /* --- Action Buttons --- */
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 1rem;
            flex-wrap: wrap;
            justify-content: flex-end;
            /* Align buttons right */
        }

        .action-buttons button,
        .action-buttons a.btn {
            padding: 0.6rem 1rem;
            margin-top: 0;
            /* Remove top margin */
        }


        /* --- Instructions --- */
        .instructions {
            background-color: #fff;
            padding: 1rem;
            border-radius: 0.25rem;
            margin-bottom: 1rem;
            border-left: 4px solid var(--primary-color);
            border: 1px solid var(--border-color);
            font-size: 0.9rem;
        }

        .instructions summary {
            cursor: pointer;
            font-weight: bold;
        }

        .instructions ol {
            margin-top: 0.5rem;
            padding-left: 20px;
        }


        /* --- Chat --- */
        .chat-container {
            position: fixed;
            bottom: 0;
            right: 20px;
            width: 320px;
            /* Slightly wider */
            max-width: 90vw;
            /* Max width on small screens */
            max-height: 80vh;
            /* Max height */
            height: 450px;
            /* Taller chat */
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 5px 5px 0 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease-in-out;
            /* Smooth transition */
        }

        .chat-header {
            background-color: var(--primary-color);
            color: white;
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--primary-color);
        }

        .chat-header span:first-child {
            font-weight: bold;
        }

        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            background-color: #f9f9f9;
        }

        .chat-input {
            display: flex;
            padding: 10px;
            border-top: 1px solid #eee;
            background-color: white;
        }

        .chat-input input {
            flex-grow: 1;
            margin-right: 10px;
            border-radius: 15px;
            /* Rounded input */
            padding: 0.4rem 0.8rem;
        }

        .chat-input button {
            border-radius: 15px;
            /* Rounded button */
            padding: 0.4rem 0.8rem;
        }

        .chat-message {
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .chat-user {
            font-weight: bold;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            font-size: 0.85rem;
        }

        .user-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
            background-color: #eee;
            /* Placeholder color */
        }

        .chat-time {
            font-size: 0.75em;
            color: #999;
            margin-left: 8px;
            font-weight: normal;
        }

        .chat-text {
            background-color: white;
            padding: 8px 12px;
            border-radius: 10px;
            display: inline-block;
            max-width: 95%;
            word-wrap: break-word;
            margin-left: 32px;
            /* Align with avatar */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
            font-size: 0.9rem;
        }

        .chat-system {
            text-align: center;
            color: #666;
            font-style: italic;
            margin: 10px 0;
            font-size: 0.85em;
        }

        .chat-container.minimized {
            transform: translateY(calc(100% - 45px));
            /* Adjust based on header height */
            box-shadow: none;
        }

        .chat-container.minimized .chat-messages,
        .chat-container.minimized .chat-input {
            display: none;
        }


        /* --- Utilities & Misc --- */
        .hidden {
            display: none !important;
        }

        /* Use important if needed */

        .loader {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            width: 100%;
        }

        .loader::after {
            content: " ";
            display: block;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 4px solid var(--primary-color);
            border-color: var(--primary-color) transparent var(--primary-color) transparent;
            animation: loader 1.2s linear infinite;
        }

        @keyframes loader {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* --- Draft Order Management --- */
        .draft-order-container {
            max-height: 300px;
            overflow-y: auto;
        }

        .draft-team-item {
            padding: 8px 12px;
            background-color: #fff;
            border: 1px solid #ddd;
            margin-bottom: 8px;
            border-radius: 4px;
            cursor: grab;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .draft-team-item:hover {
            background-color: #f4f6f9;
        }

        .draft-team-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .draft-team-name {
            font-weight: bold;
        }

        .draft-team-picks {
            background-color: var(--primary-color);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
        }

        .banked-pick-item {
            background-color: #e8f4ff !important;
            border: 1px solid #b8daff !important;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
        }

        .banked-pick-count {
            font-weight: bold;
            color: var(--primary-color);
        }

        .banked-pick-row {
            background-color: #e8f4ff !important;
            /* Light blue background */
        }

        .banked-pick-row:hover {
            background-color: #d1e7ff !important;
            /* Slightly darker blue on hover */
        }

        .undo-banked-pick-button {
            background-color: #795548 !important;
            /* Brown color to match bank button */
            border-color: #5d4037 !important;
        }

        .banked-picks-instructions {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .draft-team-pick-type {
            font-size: 0.8rem;
            color: #666;
            padding: 2px 6px;
            border-radius: 10px;
            background-color: #f0f0f0;
        }

        .empty-message {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 15px;
        }

        .round-indicator {
            display: inline-block;
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.85rem;
            margin-left: 5px;
        }

        .eliminated-player {
            text-decoration: line-through;
            color: #999;
            position: relative;
        }

        .eliminated-player::after {
            content: 'ELIMINATED';
            position: absolute;
            right: 10px;
            font-size: 0.7rem;
            background-color: #dc3545;
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 0.8;
        }

        /* Hide label in smaller cells */
        .eliminated-player td:nth-child(2)::after {
            display: none;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--primary-color);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            animation: fadeInOut 5s forwards;
            font-size: 0.9rem;
        }
        
        /* Draft Queue Styles */
        .my-draft-queue-section {
            margin-bottom: 1.5rem;
        }
        
        .queue-instructions {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 1rem;
        }
        
        .queue-container {
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            background-color: #fff;
            padding: 0.5rem;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .draft-queue-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .queue-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 0.25rem;
            cursor: grab;
        }
        
        .queue-item:hover {
            background-color: #e9ecef;
        }
        
        .queue-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .queue-item-info {
            flex-grow: 1;
            display: flex;
            align-items: center;
        }
        
        .queue-item-name {
            font-weight: bold;
            margin-bottom: 0.25rem;
        }
        
        .queue-item-details {
            font-size: 0.85rem;
            color: #6c757d;
        }
        
        .queue-item-rank {
            background-color: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 0.8rem;
            font-weight: bold;
            margin-right: 0.75rem;
            flex-shrink: 0;
        }
        
        .remove-from-queue {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 0.25rem;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            cursor: pointer;
        }
        
        .remove-from-queue:hover {
            background-color: #c82333;
        }
        
        .add-to-queue {
            background-color: #6c757d;
            margin-right: 0.5rem;
        }

        @keyframes fadeInOut {

            0%,
            100% {
                opacity: 0;
                transform: translateY(-10px);
            }

            10%,
            90% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .error-message {
            color: #dc3545;
            font-size: 0.85rem;
            margin-top: 5px;
        }

        /* Specific League Selection Styling */
        #league-list .league-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            /* Allow wrapping */
            gap: 10px;
        }

        #league-list .league-item:last-child {
            border-bottom: none;
        }

        #league-list .league-name {
            font-size: 1.1rem;
        }

        #league-list .league-details {
            font-size: 0.85rem;
        }

        #league-list .btn {
            margin-top: 0;
            padding: 0.4rem 0.8rem;
            font-size: 0.85rem;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            h2 {
                font-size: 1.3rem;
            }

            .controls-section .controls-grid {
                grid-template-columns: 1fr;
            }

            /* Stack controls */
            .search-container,
            .position-filter-container,
            .view-options-container {
                margin-bottom: 1rem;
            }

            .league-info {
                flex-direction: column;
                align-items: flex-start;
            }

            .table-container {
                max-height: 350px;
            }

            /* Reduce height on smaller screens */
            th,
            td {
                font-size: 0.8rem;
                padding: 0.5rem 0.6rem;
            }

            /* Optionally hide less important table columns */
            .hide-mobile {
                display: none;
            }

            th:nth-child(4),
            td:nth-child(4),
            /* GP */
            th:nth-child(8),
            td:nth-child(8),
            /* W */
            th:nth-child(9),
            td:nth-child(9)

            /* SO */
                {
                /* Example: Hiding GP, W, SO on small screens */
                /* display: none; */
            }
        }

        @media (max-width: 576px) {
            .chat-container {
                width: 95vw;
            }

            .action-buttons {
                justify-content: center;
            }

            .action-buttons button,
            .action-buttons a.btn {
                width: 100%;
                text-align: center;
                margin-bottom: 0.5rem;
            }

            .drafted-team-filter {
                flex-direction: column;
                align-items: stretch;
            }

            .drafted-team-filter select {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <header class="auth-container">
        <button id="login-btn" class="btn">Sign in with Google</button>
        <button id="logout-btn" class="btn secondary hidden">Sign Out</button>
        <div id="auth-status">You are not signed in</div>
    </header>

    <main class="container">
        <div id="content-container" class="hidden">
            <div id="league-info" class="league-info hidden">
                <div>
                    <div class="league-name" id="league-name">League Name Loading...</div>
                    <div class="league-details">
                        <span id="league-team-count">X Teams</span>
                    </div>
                </div>
                <a href="manage-leagues.html" class="btn secondary">Manage Leagues</a>
            </div>

            <div id="league-select-container" class="league-selection-area">
                <h2>Select a League</h2>
                <p>Please select a league or create/join a new one:</p>
                <div id="league-list">
                    <div class="loader"></div>
                </div>
                <div class="action-buttons" style="justify-content: flex-start; margin-top: 1rem;">
                    <a href="manage-leagues.html" class="btn">Create or Join League</a>
                </div>
            </div>

            <div id="draft-container" class="hidden">
                <div class="full-width-section">
                    <h1>Fantasy Hockey Draftcentre</h1>
                    <!-- Issue 5: Update disclaimer text -->
                    <p style="margin-top: -10px; color: #666; font-size: 0.9rem;">Stats shown are from the current
                        regular season</p>
                </div>

                <!-- Commissioner Controls - Placed near the top -->
                <div id="commissioner-controls" class="commissioner-controls card hidden full-width-section">
                    <div
                        style="display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 10px;">
                        <div>
                            <strong>Commissioner Mode:</strong>
                            <div class="commish-toggle-container">
                                <label class="switch">
                                    <input type="checkbox" id="commissioner-mode-toggle">
                                    <span class="slider"></span>
                                </label>
                                <label for="commissioner-mode-toggle">Draft for any team</label>
                            </div>
                            <span style="font-size: 0.85rem; color: #6c757d;">(Allows drafting when it's not your turn,
                                assigns pick to the current team)</span>
                        </div>
                        <div style="border-left: 1px solid #e0d9b8; padding-left: 15px;">
                            <strong>Playoff Round Management:</strong>
                            <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                                <span id="current-round-display" style="font-size: 0.9rem; color: #856404;">Current
                                    Round: <span id="current-round-number">1</span></span>
                                <button id="conclude-round-btn" class="btn">Conclude Round</button>
                            </div>
                        </div>
                    </div>
                    <div id="draft-order-manager" class="hidden"
                        style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0d9b8;">
                        <strong>Next Round Draft Order Management:</strong>
                        <div style="margin-top: 10px; display: flex; gap: 10px; align-items: flex-start;">
                            <div style="flex: 1;">
                                <label for="draft-order-list" style="display: block; margin-bottom: 5px;">Drag teams to
                                    set order:</label>
                                <div id="draft-order-list" class="draft-order-container"
                                    style="border: 1px solid #ddd; padding: 10px; min-height: 100px; border-radius: 4px; background: #f8f8f8;">
                                    <!-- Teams will be added here as draggable items -->
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <label for="banked-picks-list" style="display: block; margin-bottom: 5px;">Teams with
                                    banked picks:</label>
                                <div id="banked-picks-list"
                                    style="border: 1px solid #ddd; padding: 10px; min-height: 100px; border-radius: 4px; background: #f8f8f8;">
                                    <!-- Teams with banked picks will be shown here -->
                                    <div class="empty-message">No banked picks yet</div>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 10px;">
                            <button id="save-draft-order-btn" class="btn">Save Draft Order & Start Next Round</button>
                            <button id="cancel-draft-order-btn" class="btn secondary">Cancel</button>
                        </div>
                    </div>
                </div>

                <div class="full-width-section">
                    <div class="instructions">
                        <details>
                            <summary><strong>How to use the Draftcentre</strong> (click to expand)</summary>
                            <ol>
                                <li><strong>Browse & Search:</strong> Use filters and search to find available players.
                                </li>
                                <li><strong>Sort:</strong> Click column headers to sort players.</li>
                                <li><strong>Draft:</strong> Click the "Draft" button when it's your turn (or if
                                    Commissioner Mode is on).</li>
                                <li><strong>View Picks:</strong> See drafted players in the "Drafted Players" section.
                                </li>
                                <li><strong>Chat:</strong> Discuss picks with league members in the chat window.</li>
                            </ol>
                            <p><strong>Snake Draft Format:</strong> This draft uses a snake format - the order reverses each round. For example, if you draft 1st in Round 1, you'll draft last in Round 2, first in Round 3, and so on.</p>
                            <p><em>Note: The commissioner can start the draft and enable Commissioner Mode to manage
                                    picks.</em></p>
                        </details>
                    </div>
                </div>

                <!-- Status Section: Current Drafter & Start Button -->
                <div class="status-section card full-width-section">
                    <div id="current-drafter" class="current-drafter hidden">
                        <p>
                            <strong>Current Pick:</strong> <span id="current-drafter-name">Waiting to start
                                draft...</span>
                            <span id="round-display" class="round-indicator">Round 1</span>
                        </p>
                        <p id="banked-picks-info" class="hidden"
                            style="margin-top: 5px; font-size: 0.85rem; color: #0055a4;">
                            <span id="current-team-banked-picks">0</span> banked picks available
                        </p>
                    </div>
                    <div class="draft-actions">
                        <button id="start-draft-btn" class="btn hidden">Start Draft</button>
                        <button id="bank-pick-btn" class="btn secondary hidden">Bank This Pick</button>
                    </div>
                </div>
                
                <!-- Draft Order Display Section -->
                <div class="draft-order-display card full-width-section">
                    <h3 style="margin-top: 0.5rem; margin-bottom: 0.75rem;">Draft Order</h3>
                    <div id="draft-order-display" class="draft-order-list">
                        <!-- Draft order will be displayed here -->
                        <div class="loader"></div>
                    </div>
                </div>
                
                <style>
                    .draft-order-display {
                        margin-bottom: 1.5rem;
                    }
                    .draft-order-list {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px;
                        align-items: center;
                    }
                    .draft-order-item {
                        background-color: #fff;
                        border: 1px solid var(--border-color);
                        border-radius: 0.25rem;
                        padding: 0.6rem 1rem;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    }
                    .draft-order-item.current {
                        background-color: var(--success-bg);
                        border-color: var(--success-border);
                        font-weight: bold;
                    }
                    .draft-order-number {
                        background-color: var(--primary-color);
                        color: white;
                        width: 24px;
                        height: 24px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 50%;
                        font-size: 0.8rem;
                        font-weight: bold;
                    }
                    .draft-order-item.current .draft-order-number {
                        background-color: #28a745;
                    }
                    .banked-pick-indicator {
                        background-color: #795548;
                        color: white;
                        font-size: 0.7rem;
                        padding: 2px 6px;
                        border-radius: 10px;
                        margin-left: 5px;
                    }
                    
                    @media (max-width: 768px) {
                        .draft-order-list {
                            flex-direction: column;
                            align-items: stretch;
                        }
                        .draft-order-item {
                            width: 100%;
                        }
                    }
                </style>

                <!-- Control Section: Search, Filters, Options -->
                <div class="controls-section card full-width-section">
                    <div class="controls-grid">
                        <div class="search-container">
                            <label for="searchInput" class="visually-hidden">Search Players</label>
                            <!-- Hidden label for accessibility -->
                            <input type="text" id="searchInput" placeholder="Search by player name..."
                                oninput="filterPlayers()">
                        </div>
                        <div class="position-filter-container">
                            <div class="position-filter">
                                <button class="position-btn active" data-position="all">All</button>
                                <button class="position-btn" data-position="C">C</button>
                                <button class="position-btn" data-position="LW">LW</button>
                                <button class="position-btn" data-position="RW">RW</button>
                                <button class="position-btn" data-position="D">D</button>
                                <button class="position-btn" data-position="G">G</button>
                            </div>
                        </div>
                        <div class="view-options-container">
                            <label for="showDrafted"><input type="checkbox" id="showDrafted" onchange="filterPlayers()">
                                Show Drafted Players</label>
                            </label>
                        </div>
                        <div class="refresh-container">
                            <button id="refresh-players-btn" class="btn secondary" title="Reload player data">
                                ↻ Refresh Players
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Available Players Section -->
                <div class="available-players-section">
                    <div class="card">
                        <h2>Available Players</h2>
                        <div class="table-container">
                            <table id="playerTable">
                                <thead>
                                    <tr>
                                        <th data-sort="fullName">Name</th>
                                        <th data-sort="position">Pos</th>
                                        <th data-sort="teamAbbreviation">Team</th>
                                        <th data-sort="gamesPlayed" class="hide-mobile">GP</th>
                                        <th data-sort="goals" class="skater-stat">G</th>
                                        <th data-sort="assists" class="skater-stat">A</th>
                                        <th data-sort="points" class="skater-stat">PTS</th>
                                        <th data-sort="wins" class="goalie-stat hide-mobile">W</th>
                                        <th data-sort="shutouts" class="goalie-stat hide-mobile">SO</th>
                                        <th>Action</th>
                                    </tr>
                                </thead>
                                <tbody id="playerTableBody">
                                    <!-- Player data will be loaded here -->
                                    <tr>
                                        <td colspan="10" style="text-align: center;">
                                            <div class="loader"></div>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <!-- My Draft Queue Section -->
                <div class="my-draft-queue-section">
                    <div class="card">
                        <h2>My Draft Queue</h2>
                        <p class="queue-instructions">Add players to your draft queue to keep track of who you want to draft. Drag players to reorder them. This list is private and only visible to you.</p>
                        <div id="queue-container" class="queue-container">
                            <div id="empty-queue-message" class="empty-message">Your draft queue is empty. Add players from the Available Players list.</div>
                            <ul id="draft-queue-list" class="draft-queue-list">
                                <!-- Draft queue items will be added here -->
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Drafted Players Section -->
                <div class="drafted-players-section">
                    <div class="card">
                        <h2>Drafted Players</h2>
                        <div class="drafted-team-filter">
                            <label for="draftedTeamFilter">Show Team:</label>
                            <select id="draftedTeamFilter" onchange="filterDraftedPlayers()">
                                <option value="all">All Teams</option>
                                <!-- Team options will be dynamically added -->
                            </select>
                        </div>
                        <div class="table-container">
                            <table id="draftedTable">
                                <thead>
                                    <tr>
                                        <th data-sort="draftNumber" style="width: 5%;">Pick#</th>
                                        <th data-sort="Player">Name</th>
                                        <th data-sort="Position">Pos</th>
                                        <th data-sort="NHL Team" class="hide-mobile">NHL Team</th>
                                        <th data-sort="Team">Fantasy Team</th>
                                        <th>Action</th>
                                    </tr>
                                </thead>
                                <tbody id="draftedTableBody">
                                    <!-- Drafted players will be shown here -->
                                    <tr>
                                        <td colspan="6" style="text-align: center;">Loading drafted players...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="action-buttons full-width-section">
                    <a href="#" id="back-to-league-link" class="btn secondary hidden">Back to League Details</a>
                    <!-- Start Draft button moved to status section -->
                </div>
            </div> <!-- End #draft-container -->
        </div> <!-- End #content-container -->
    </main>

    <!-- Chat remains floating -->
    <div id="chat-container" class="chat-container hidden minimized">
        <div class="chat-header" id="chat-header">
            <span>Draft Chat</span>
            <span id="chat-toggle">+</span>
        </div>
        <div class="chat-messages" id="chat-messages">
            <!-- Chat messages will appear here -->
        </div>
        <div class="chat-input">
            <input type="text" id="chat-input" placeholder="Type a message...">
            <button id="chat-send" class="btn">Send</button>
        </div>
    </div>

    <script src="firebaseConfig.js"></script>
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut, setPersistence, browserSessionPersistence } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { getDatabase, ref, set, push, onValue, get, update, off, query, limitToLast, serverTimestamp, onDisconnect } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js"; // Added serverTimestamp and onDisconnect

        // Placeholder Firebase configuration
        const fallbackFirebaseConfig = {
            apiKey: "PLACEHOLDER_API_KEY",
            authDomain: "playofffantasyhockey.firebaseapp.com",
            databaseURL: "https://playofffantasyhockey-default-rtdb.firebaseio.com",
            projectId: "playofffantasyhockey",
            storageBucket: "playofffantasyhockey.appspot.com",
            messagingSenderId: "PLACEHOLDER_SENDER_ID",
            appId: "PLACEHOLDER_APP_ID"
        };

        const app = initializeApp(window.firebaseConfig || fallbackFirebaseConfig);
        const auth = getAuth();
        setPersistence(auth, browserSessionPersistence).catch(console.error);
        const provider = new GoogleAuthProvider();
        const database = getDatabase();

        // --- Global State ---
        let currentUser = null;
        let allPlayers = [];
        let draftedPlayers = []; // Holds { ..., firebaseKey: '...', draftNumber: X }
        let eliminatedPlayers = new Set(); // Track eliminated player IDs
        let eliminatedNHLTeams = new Set(); // Track eliminated NHL team codes (BOS, NYR, etc.)
        let leagueData = null;
        let leagueId = null;
        let currentPositionFilter = 'all';
        let currentSortColumn = null; // For available players table
        let currentSortDirection = 'asc'; // For available players table
        let currentTeams = {}; // { uid: { name, isCommissioner, photoURL }, ... }
        let isCommissioner = false;
        let commissionerModeActive = false; // State for the toggle
        let chatListeners = {};
        let playerListeners = {};
        let draftStatusListener = null; // Ref to the draft status listener
        let eliminatedPlayersListener = null; // Ref to the eliminated players listener
        let eliminatedTeamsListener = null; // Ref to the eliminated NHL teams listener
        
        // Draft Queue Variables
        let myDraftQueue = []; // Array of player objects in the queue
        let draftQueueListener = null; // Ref to the draft queue listener

        // Playoff round draft state
        let currentRound = 1; // Current playoff round
        let bankedPicks = {}; // { uid: count } - Number of banked picks per team
        let nextRoundDraftOrder = []; // Array of objects with uid and pickType properties

        // --- DOM Elements ---
        const loginBtn = document.getElementById('login-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const authStatus = document.getElementById('auth-status');
        const contentContainer = document.getElementById('content-container');
        const leagueSelectContainer = document.getElementById('league-select-container');
        const leagueListEl = document.getElementById('league-list');
        const draftContainer = document.getElementById('draft-container');
        const leagueInfoContainer = document.getElementById('league-info');
        const leagueNameEl = document.getElementById('league-name');
        const leagueTeamCountEl = document.getElementById('league-team-count');
        const draftedTeamFilter = document.getElementById('draftedTeamFilter');
        const startDraftBtn = document.getElementById('start-draft-btn');
        const currentDrafterContainer = document.getElementById('current-drafter');
        const currentDrafterName = document.getElementById('current-drafter-name');
        const playerTableBody = document.getElementById('playerTableBody');
        const draftedTableBody = document.getElementById('draftedTableBody');
        const chatContainer = document.getElementById('chat-container');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSend = document.getElementById('chat-send');
        const chatHeader = document.getElementById('chat-header');
        const chatToggle = document.getElementById('chat-toggle');
        const backToLeagueLink = document.getElementById('back-to-league-link');
        const commissionerControls = document.getElementById('commissioner-controls');
        const commissionerModeToggle = document.getElementById('commissioner-mode-toggle');
        
        // Draft Queue DOM Elements
        const draftQueueList = document.getElementById('draft-queue-list');
        const emptyQueueMessage = document.getElementById('empty-queue-message');

        // New playoff round draft elements
        const roundDisplay = document.getElementById('round-display');
        const currentRoundNumber = document.getElementById('current-round-number');
        const concludeRoundBtn = document.getElementById('conclude-round-btn');
        const bankPickBtn = document.getElementById('bank-pick-btn');
        const bankedPicksInfo = document.getElementById('banked-picks-info');
        const currentTeamBankedPicks = document.getElementById('current-team-banked-picks');
        const draftOrderManager = document.getElementById('draft-order-manager');
        const draftOrderList = document.getElementById('draft-order-list');
        const bankedPicksList = document.getElementById('banked-picks-list');
        const saveDraftOrderBtn = document.getElementById('save-draft-order-btn');
        const cancelDraftOrderBtn = document.getElementById('cancel-draft-order-btn');

        // --- Initialization ---
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('league')) {
            leagueId = urlParams.get('league');
        }

        // Bank pick button event listener
        if (bankPickBtn) {
            bankPickBtn.addEventListener('click', handleBankPick);
        }

        // --- Auth ---
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                loginBtn.classList.add('hidden');
                logoutBtn.classList.remove('hidden');
                authStatus.textContent = `Signed in as ${user.displayName}`;
                contentContainer.classList.remove('hidden');
                setupAuthPersistence();
                storeUserProfile(user);

                if (leagueId) {
                    loadLeague(leagueId);
                    backToLeagueLink.href = `league.html?id=${leagueId}`;
                    backToLeagueLink.classList.remove('hidden');
                } else {
                    loadUserLeagues();
                    backToLeagueLink.classList.add('hidden');
                }
            } else {
                currentUser = null;
                localStorage.removeItem('fantasy_hockey_user');
                loginBtn.classList.remove('hidden');
                logoutBtn.classList.add('hidden');
                authStatus.textContent = 'You are not signed in';
                contentContainer.classList.add('hidden');
                chatContainer.classList.add('hidden');
                backToLeagueLink.classList.add('hidden');
                commissionerControls.classList.add('hidden'); // Hide commish controls on logout
                cleanupListeners();
                resetUIState(); // Clear dynamic data
            }
        });

        loginBtn.addEventListener('click', () => {
            signInWithPopup(auth, provider).catch(error => {
                console.error("Auth error:", error);
                authStatus.textContent = `Error: ${error.message}`;
                showNotification(`Sign-in Error: ${error.message}`, 7000);
            });
        });

        logoutBtn.addEventListener('click', () => {
            signOut(auth).then(() => {
                window.location.reload(); // Force reload for clean state
            }).catch(error => {
                console.error("Sign out error:", error);
                showNotification(`Sign-out Error: ${error.message}`, 7000);
            });
        });

        function storeUserProfile(user) {
            const userRef = ref(database, `users/${user.uid}/profile`);
            update(userRef, { // Use update to avoid overwriting other potential data
                uid: user.uid,
                displayName: user.displayName,
                email: user.email,
                photoURL: user.photoURL || null,
                lastLogin: serverTimestamp() // Use server timestamp
            }).catch(error => console.error("Error storing user profile:", error));
        }

        function resetUIState() {
            // Clear tables, dropdowns, etc.
            leagueListEl.innerHTML = '';
            if (playerTableBody) playerTableBody.innerHTML = '';
            if (draftedTableBody) draftedTableBody.innerHTML = '';
            if (draftedTeamFilter) draftedTeamFilter.innerHTML = '<option value="all">All Teams</option>';
            if (leagueNameEl) leagueNameEl.textContent = '';
            if (leagueTeamCountEl) leagueTeamCountEl.textContent = '';
            if (currentDrafterName) currentDrafterName.textContent = 'Draft not started';
            if (currentDrafterContainer) currentDrafterContainer.classList.add('hidden');
            if (startDraftBtn) startDraftBtn.classList.add('hidden');
            
            // Clear draft queue
            if (draftQueueList) draftQueueList.innerHTML = '';
            if (emptyQueueMessage) emptyQueueMessage.classList.remove('hidden');
            
            // Reset global vars
            allPlayers = [];
            draftedPlayers = [];
            myDraftQueue = [];
            leagueData = null;
            leagueId = null; // Reset leagueId as well
            currentTeams = {};
            isCommissioner = false;
            commissionerModeActive = false;
        }

        // --- League Loading & Selection ---
        function loadUserLeagues() {
            if (!currentUser) return;
            resetUIState(); // Clear previous league state before loading list
            leagueSelectContainer.classList.remove('hidden');
            draftContainer.classList.add('hidden');
            leagueInfoContainer.classList.add('hidden');
            leagueListEl.innerHTML = '<div class="loader"></div>';

            const userLeaguesRef = ref(database, `users/${currentUser.uid}/leagues`);
            get(userLeaguesRef).then((snapshot) => {
                leagueListEl.innerHTML = ''; // Clear loader
                if (snapshot.exists()) {
                    const leagues = snapshot.val();
                    if (typeof leagues === 'object' && leagues !== null) {
                        const leagueEntries = Object.values(leagues); // Get array of league objects
                        if (leagueEntries.length > 0) {
                            leagueEntries
                                .sort((a, b) => (a.name || '').localeCompare(b.name || '')) // Sort by name
                                .forEach(league => {
                                    if (league && league.leagueId && league.name) {
                                        const leagueItem = document.createElement('div');
                                        leagueItem.className = 'league-item';
                                        leagueItem.innerHTML = `
                 <div>
                     <div class="league-name">${league.name}</div>
                     <div class="league-details">Role: ${league.role || 'Member'}</div>
                 </div>
                 <a href="draftcentre.html?league=${league.leagueId}" class="btn">Open Draft</a>
             `;
                                        leagueListEl.appendChild(leagueItem);
                                    } else {
                                        console.warn("Skipping invalid league data:", league);
                                    }
                                });
                        } else {
                            leagueListEl.innerHTML = '<p>You haven\'t joined any leagues yet.</p>';
                        }
                    } else {
                        console.error("User leagues data is not in the expected format:", leagues);
                        leagueListEl.innerHTML = `<p>Could not load league data.</p>`;
                    }
                } else {
                    leagueListEl.innerHTML = `<p>You haven\'t joined any leagues yet.</p>`;
                }
            }).catch((error) => {
                console.error("Error loading leagues:", error);
                leagueListEl.innerHTML = `<p>Error loading leagues: ${error.message}</p>`;
                showNotification(`Error loading your leagues: ${error.message}`, 7000);
            });
        }

        function loadLeague(leagueIdToLoad) {
            if (!currentUser || !leagueIdToLoad) {
                console.error("Cannot load league without user or league ID");
                loadUserLeagues();
                return;
            }
            resetUIState(); // Clear previous league state FIRST
            leagueId = leagueIdToLoad; // Set global leagueId AFTER resetting
            console.log(`Loading league: ${leagueId}`);

            const leagueRef = ref(database, `leagues/${leagueId}`);
            get(leagueRef).then((snapshot) => {
                if (snapshot.exists()) {
                    leagueData = snapshot.val();
                    console.log("League data loaded:", leagueData);

                    // ADD DEBUG LOGS HERE
                    console.log("Current user UID:", currentUser.uid);
                    console.log("Team IDs:", leagueData.teams ? Object.keys(leagueData.teams) : "No teams data found");

                    if (!leagueData.teams || !leagueData.teams[currentUser.uid]) {
                        console.warn("League teams object:", leagueData.teams);
                        console.warn("Current user UID:", currentUser.uid);
                        handleNoAccessToLeague(leagueData);
                        return;
                    }

                    isCommissioner = leagueData.teams[currentUser.uid]?.isCommissioner ?? false;
                    console.log(`User is commissioner: ${isCommissioner}`);

                    showDraftInterface();
                    window.addEventListener('beforeunload', handlePageLeave);
                    setupLeagueListeners(); // Setup real-time updates
                    loadPlayerData(); // Load static player list
                } else {
                    console.error(`League with ID ${leagueId} not found.`);
                    showNotification("League not found.");
                    leagueId = null;
                    cleanupListeners();
                    loadUserLeagues(); // Go back to selection
                }
            }).catch((error) => {
                console.error(`Error loading league ${leagueId}:`, error);
                showNotification(`Error loading league: ${error.message}`, 7000);
                leagueId = null;
                cleanupListeners();
                loadUserLeagues();
            });
        }

        function handlePageLeave(event) {
            // Best effort notification - not guaranteed
            if (currentUser && leagueId && leagueData?.teams?.[currentUser.uid]) {
                const presenceRef = ref(database, `leagues/${leagueId}/presence/${currentUser.uid}`);
                update(presenceRef, { online: false, lastSeen: serverTimestamp() }); // Indicate offline
                console.log("Attempting to mark user as offline (not guaranteed)");
            }
        }

        // --- Draft Interface Setup & Updates ---
        function showDraftInterface() {
            leagueSelectContainer.classList.add('hidden');
            draftContainer.classList.remove('hidden');
            leagueInfoContainer.classList.remove('hidden');
            chatContainer.classList.remove('hidden'); // Show chat

            leagueNameEl.textContent = leagueData?.name ?? 'League Name';
            const teamCount = Object.keys(leagueData?.teams ?? {}).length;
            leagueTeamCountEl.textContent = `${teamCount} Teams`;

            populateTeamFilter();

            // Issue 4: Setup Commissioner Controls
            setupCommissionerControls();

            // Listen for draft status changes
            if (draftStatusListener) {
                // Correct way to remove specific listener: use off() with ref, eventType, and the listener function itself
                const draftStatusRef = ref(database, `leagues/${leagueId}/draftStatus`);
                off(draftStatusRef, 'value', draftStatusListener);
                console.log("Removed previous draft status listener.");
            }
            const draftStatusRef = ref(database, `leagues/${leagueId}/draftStatus`);
            draftStatusListener = onValue(draftStatusRef, (snapshot) => { // Store the listener function
                const draftStatus = snapshot.val();
                console.log("Draft status updated:", draftStatus);
                leagueData.draftStatus = draftStatus; // Update local state

                updateDraftStatusUI(draftStatus); // Update UI based on new status
                filterPlayers(); // Re-filter players to update button states
                updateDraftOrderDisplay(); // Update the draft order display

            }, (error) => {
                console.error("Error reading draft status:", error);
                currentDrafterName.textContent = 'Error loading status';
                filterPlayers(); // Still filter, buttons likely disabled
                showNotification("Error syncing draft status.", 7000);
            });
            console.log("Added draft status listener.");

            startDraftBtn.removeEventListener('click', startDraft); // Remove previous listener
            startDraftBtn.addEventListener('click', startDraft);
        }

        // Setup commissioner controls visibility and listeners
        function setupCommissionerControls() {
            if (isCommissioner) {
                commissionerControls.classList.remove('hidden');
                commissionerModeToggle.checked = commissionerModeActive; // Set initial state
                commissionerModeToggle.removeEventListener('change', handleCommissionerToggle); // Remove old listener
                commissionerModeToggle.addEventListener('change', handleCommissionerToggle);

                // Set up conclude round button
                if (concludeRoundBtn) {
                    concludeRoundBtn.removeEventListener('click', handleConcludeRound);
                    concludeRoundBtn.addEventListener('click', handleConcludeRound);
                }

                // Setup draft order manager save/cancel buttons
                if (saveDraftOrderBtn) {
                    saveDraftOrderBtn.removeEventListener('click', handleSaveDraftOrder);
                    saveDraftOrderBtn.addEventListener('click', handleSaveDraftOrder);
                }

                if (cancelDraftOrderBtn) {
                    cancelDraftOrderBtn.removeEventListener('click', handleCancelDraftOrder);
                    cancelDraftOrderBtn.addEventListener('click', handleCancelDraftOrder);
                }

                // Update current round display
                if (currentRoundNumber) {
                    currentRoundNumber.textContent = currentRound.toString();
                }
            } else {
                commissionerControls.classList.add('hidden');
                commissionerModeActive = false; // Ensure mode is off if not commissioner
            }
        }

        // Handle commissioner toggle change
        function handleCommissionerToggle() {
            commissionerModeActive = commissionerModeToggle.checked;
            console.log(`Commissioner Mode ${commissionerModeActive ? 'Enabled' : 'Disabled'}`);
            // Re-filter players to update draft button enabled state based on the new mode
            filterPlayers();
            // Optional: Show notification
            showNotification(`Commissioner Mode ${commissionerModeActive ? 'ON' : 'OFF'}`, 2000);
        }

        // Handle conclude round button click
        function handleConcludeRound() {
            if (!isCommissioner) {
                showNotification("Only the commissioner can conclude rounds.");
                return;
            }

            // Check if draft is active
            if (!leagueData?.draftStatus?.active) {
                showNotification("Cannot conclude round: Draft is not active.");
                return;
            }

            // Verify all picks for the round have been made or banked
            const draftOrder = leagueData?.draftStatus?.draftOrder || [];
            const currentPickIndex = (leagueData?.draftStatus?.pickNumber || 1) - 1;

            if (currentPickIndex < draftOrder.length) {
                // There are still picks remaining in this round
                const remainingPicks = draftOrder.length - currentPickIndex;
                showNotification(`Cannot conclude round: There are still ${remainingPicks} picks remaining.`, 7000);
                return;
            }

            // Confirm before proceeding
            if (!confirm(`Are you sure you want to conclude Round ${currentRound}? This will pause the draft and allow you to set up the next round.`)) {
                return;
            }

            // Pause the current draft
            const draftStatusRef = ref(database, `leagues/${leagueId}/draftStatus`);
            update(draftStatusRef, { active: false })
                .then(() => {
                    console.log(`Round ${currentRound} concluded.`);
                    showNotification(`Round ${currentRound} concluded. Set up the next round.`);

                    // Show the draft order manager
                    if (draftOrderManager) {
                        draftOrderManager.classList.remove('hidden');
                        populateDraftOrderManager();
                    }

                    // Add system chat message
                    addChatMessage({
                        type: 'system',
                        text: `Round ${currentRound} concluded by commissioner. Preparing for Round ${currentRound + 1}.`,
                        timestamp: serverTimestamp()
                    });
                })
                .catch((error) => {
                    console.error("Error concluding round:", error);
                    showNotification(`Error concluding round: ${error.message}`, 7000);
                });
        }

        // Populate the draft order manager with teams and banked picks
        function populateDraftOrderManager() {
            if (!draftOrderList || !bankedPicksList) return;

            // Clear existing items
            draftOrderList.innerHTML = '';
            bankedPicksList.innerHTML = '';

            // Get the teams with their banked picks
            const teamsWithBanks = Object.entries(currentTeams).map(([uid, team]) => ({
                uid,
                name: team.name,
                bankedPicks: bankedPicks[uid] || 0
            }));

            // Sort teams by name
            teamsWithBanks.sort((a, b) => a.name.localeCompare(b.name));

            // Populate the draft order list - One entry per team (base picks)
            teamsWithBanks.forEach(team => {
                // Create a standard pick for each team
                const teamItem = document.createElement('div');
                teamItem.className = 'draft-team-item';
                teamItem.dataset.uid = team.uid;
                teamItem.dataset.pickType = 'standard'; // Mark as a standard pick
                teamItem.draggable = true;

                teamItem.innerHTML = `
            <div class="draft-team-name">${team.name}</div>
            <div class="draft-team-pick-type">Standard Pick</div>
        `;

                // Add drag events
                teamItem.addEventListener('dragstart', handleDragStart);
                teamItem.addEventListener('dragover', handleDragOver);
                teamItem.addEventListener('drop', handleDrop);
                teamItem.addEventListener('dragenter', handleDragEnter);
                teamItem.addEventListener('dragleave', handleDragLeave);
                teamItem.addEventListener('dragend', handleDragEnd);

                draftOrderList.appendChild(teamItem);
            });

            // Populate the banked picks section (these can be dragged to the draft order)
            const teamsWithBankedPicks = teamsWithBanks.filter(team => team.bankedPicks > 0);

            if (teamsWithBankedPicks.length === 0) {
                bankedPicksList.innerHTML = '<div class="empty-message">No banked picks yet</div>';
            } else {
                teamsWithBankedPicks.forEach(team => {
                    // Create banked pick items for each banked pick
                    for (let i = 0; i < team.bankedPicks; i++) {
                        const pickItem = document.createElement('div');
                        pickItem.className = 'draft-team-item banked-pick-item';
                        pickItem.dataset.uid = team.uid;
                        pickItem.dataset.pickType = 'banked'; // Mark as a banked pick
                        pickItem.draggable = true;

                        pickItem.innerHTML = `
                    <div class="draft-team-name">${team.name}</div>
                    <div class="draft-team-pick-type">Banked Pick ${i + 1}</div>
                `;

                        // Add drag events
                        pickItem.addEventListener('dragstart', handleDragStart);
                        pickItem.addEventListener('dragover', handleDragOver);
                        pickItem.addEventListener('drop', handleDrop);
                        pickItem.addEventListener('dragenter', handleDragEnter);
                        pickItem.addEventListener('dragleave', handleDragLeave);
                        pickItem.addEventListener('dragend', handleDragEnd);

                        bankedPicksList.appendChild(pickItem);
                    }
                });

                // Add instructions
                const instructions = document.createElement('div');
                instructions.className = 'banked-picks-instructions';
                instructions.innerHTML = '<p><strong>Drag banked picks to the draft order list above to include them in the next round</strong></p>';
                bankedPicksList.prepend(instructions);
            }

            // Collect the current draft order to use as initial order
            // We only include items currently in the draft order list
            updateNextRoundDraftOrder();
        }

        // Update the next round draft order based on the current UI state
        function updateNextRoundDraftOrder() {
            nextRoundDraftOrder = Array.from(draftOrderList.querySelectorAll('.draft-team-item'))
                .map(item => ({
                    uid: item.dataset.uid,
                    pickType: item.dataset.pickType
                }));

            console.log("Updated draft order:", nextRoundDraftOrder);
        }

        // Drag and drop event handlers
        function handleDragStart(e) {
            this.classList.add('dragging');
            // Store both the team ID and whether this is a banked pick
            const data = {
                uid: this.dataset.uid,
                pickType: this.dataset.pickType,
                sourceContainer: this.parentElement.id
            };
            e.dataTransfer.setData('text/plain', JSON.stringify(data));
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            this.classList.add('drag-over');
        }

        function handleDragLeave() {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over');

            try {
                // Parse the data to get team ID and pick type
                const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                const draggedUid = data.uid;
                const pickType = data.pickType;
                const sourceContainer = data.sourceContainer;

                // Get the dragged element - need to be more specific now
                const draggedSelector = `.draft-team-item[data-uid="${draggedUid}"][data-pick-type="${pickType}"]`;
                let draggedElement;

                // If it's from banked picks list, we need to handle it differently
                if (sourceContainer === 'banked-picks-list') {
                    // For banked picks being moved to draft order, clone the element
                    draggedElement = document.querySelector(`#${sourceContainer} ${draggedSelector}`);
                    if (draggedElement) {
                        const newElement = draggedElement.cloneNode(true);

                        // Re-add event listeners to the clone
                        newElement.addEventListener('dragstart', handleDragStart);
                        newElement.addEventListener('dragover', handleDragOver);
                        newElement.addEventListener('drop', handleDrop);
                        newElement.addEventListener('dragenter', handleDragEnter);
                        newElement.addEventListener('dragleave', handleDragLeave);
                        newElement.addEventListener('dragend', handleDragEnd);

                        // Add a unique ID to prevent multiple drags of the same item
                        newElement.dataset.uniqueId = `${draggedUid}-${pickType}-${Date.now()}`;

                        // Insert at the right position
                        if (this.parentElement.id === 'draft-order-list') {
                            // If dropping onto an item in the draft order list
                            draftOrderList.insertBefore(newElement, this);
                        } else {
                            // If dropping onto the draft order list container itself
                            draftOrderList.appendChild(newElement);
                        }

                        // Remove the original item from banked picks to prevent multiple drags
                        draggedElement.remove();
                    }
                } else {
                    // For items being reordered within the draft order list
                    draggedElement = document.querySelector(`#${sourceContainer} ${draggedSelector}`);
                    if (draggedElement && this !== draggedElement && this.parentElement.id === 'draft-order-list') {
                        // If dropping onto another team, insert before that team
                        draftOrderList.insertBefore(draggedElement, this);
                    }
                }
            } catch (err) {
                console.error("Error processing drag data:", err);
            }

            // Update nextRoundDraftOrder based on the new order
            updateNextRoundDraftOrder();
        }

        function handleDragEnd() {
            this.classList.remove('dragging');
            document.querySelectorAll('.draft-team-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        // Handle save draft order button
        function handleSaveDraftOrder() {
            if (!isCommissioner) {
                showNotification("Only the commissioner can save the draft order.");
                return;
            }

            // Confirm before proceeding
            const nextRound = currentRound + 1;
            const confirmMessage =
                `Are you sure you want to save this draft order and start Round ${nextRound}?\n\n` +
                `Important: This will:\n` +
                `1. Start Round ${nextRound} with the draft order you've set\n` +
                `2. Update player stats to show playoff statistics\n` +
                `3. Prevent eliminated players from being drafted\n` +
                `4. Allow teams to bank picks for future rounds`;

            if (!confirm(confirmMessage)) {
                return;
            }

            // Create the draft order directly from the ordered items in the UI
            const fullDraftOrder = [];

            // Get all team items in the current visual order
            const teamItems = Array.from(draftOrderList.querySelectorAll('.draft-team-item'));

            // For each item in the draft order, add the team UID to the draft order
            teamItems.forEach(item => {
                const uid = item.dataset.uid;
                fullDraftOrder.push(uid);
            });

            // Verify we have enough picks 
            const teamCount = Object.keys(currentTeams).length;
            const expectedMinimumPicks = teamCount; // At minimum, we should have one pick per team

            if (fullDraftOrder.length < expectedMinimumPicks) {
                const missingPicks = expectedMinimumPicks - fullDraftOrder.length;
                if (!confirm(`Warning: You have ${missingPicks} fewer picks than expected for this round. Some teams may not have a pick. Continue anyway?`)) {
                    return;
                }
            }

            // Prepare the updates
            const updates = {};

            // Update playoff round data
            updates[`leagues/${leagueId}/playoffRound/currentRound`] = currentRound + 1;
            updates[`leagues/${leagueId}/playoffRound/nextRoundDraftOrder`] = nextRoundDraftOrder;

            // Reset banked picks since they are now incorporated into the draft order
            const resetBankedPicks = {};
            Object.keys(bankedPicks).forEach(uid => {
                resetBankedPicks[uid] = 0;
            });
            updates[`leagues/${leagueId}/playoffRound/bankedPicks`] = resetBankedPicks;

            // Update draft status for the new round
            updates[`leagues/${leagueId}/draftStatus/active`] = true;
            updates[`leagues/${leagueId}/draftStatus/round`] = currentRound + 1;
            updates[`leagues/${leagueId}/draftStatus/pickNumber`] = 1;
            updates[`leagues/${leagueId}/draftStatus/draftOrder`] = fullDraftOrder;
            updates[`leagues/${leagueId}/draftStatus/currentDrafter`] = fullDraftOrder[0];

            // Apply all updates atomically
            const dbRef = ref(database);
            update(dbRef, updates)
                .then(() => {
                    console.log(`Round ${currentRound + 1} started with new draft order.`);
                    showNotification(`Round ${currentRound + 1} started!`);

                    // Hide the draft order manager
                    if (draftOrderManager) {
                        draftOrderManager.classList.add('hidden');
                    }

                    // Add system chat message
                    addChatMessage({
                        type: 'system',
                        text: `Round ${currentRound + 1} started by commissioner. Draft is now active.`,
                        timestamp: serverTimestamp()
                    });

                    // Local UI will be updated through the onValue listeners
                    // Reload player data to get playoff stats
                    allPlayers = []; // Clear player data to force reload
                    loadPlayerData();
                })
                .catch((error) => {
                    console.error("Error saving draft order:", error);
                    showNotification(`Error saving draft order: ${error.message}`, 7000);
                });
        }

        // Handle cancel draft order button
        function handleCancelDraftOrder() {
            if (draftOrderManager) {
                draftOrderManager.classList.add('hidden');
            }
        }

        // Check if all picks for the current round have been made
        function checkIfRoundComplete() {
            const draftStatus = leagueData?.draftStatus;
            if (!draftStatus || !draftStatus.active) return false;

            // Round 1 (initial draft) should never be considered "complete" - it continues until commissioner ends it
            if (currentRound <= 1) return false;

            const draftOrder = draftStatus.draftOrder || [];
            const currentPickIndex = (draftStatus.pickNumber || 1) - 1;

            // For rounds 2-4, if we've reached the end of the draft order, all picks are made
            return currentPickIndex >= draftOrder.length;
        }

        // Update conclude round button state based on round completion
        function updateConcludeRoundButton() {
            if (!isCommissioner || !concludeRoundBtn) return;

            const isRoundComplete = checkIfRoundComplete();
            const draftIsActive = leagueData?.draftStatus?.active ?? false;

            if (isRoundComplete && draftIsActive) {
                // Highlight the button if round is complete
                concludeRoundBtn.style.backgroundColor = '#28a745'; // Success green
                concludeRoundBtn.style.borderColor = '#28a745';
                concludeRoundBtn.style.fontWeight = 'bold';
                concludeRoundBtn.textContent = '✓ Conclude Round - All Picks Complete';

                // Show notification to commissioner (only once per round)
                const notificationKey = `round_complete_${leagueId}_${currentRound}`;
                if (!sessionStorage.getItem(notificationKey)) {
                    sessionStorage.setItem(notificationKey, 'true');
                    showNotification("Round complete! Please click 'Conclude Round' to set up the next round.", 10000);
                }
            } else {
                // Reset button style
                concludeRoundBtn.style.backgroundColor = '';
                concludeRoundBtn.style.borderColor = '';
                concludeRoundBtn.style.fontWeight = '';
                concludeRoundBtn.textContent = 'Conclude Round';
            }
        }

        function updateDraftStatusUI(draftStatus) {
            const draftIsActive = draftStatus?.active ?? false;

            if (draftIsActive) {
                startDraftBtn.classList.add('hidden');
                currentDrafterContainer.classList.remove('hidden');

                const currentDrafterUid = draftStatus.currentDrafter;
                const draftRound = draftStatus.round || 1;
                const pickNumber = draftStatus.pickNumber || '?'; // Overall pick number

                // Update round display - use the global currentRound to ensure consistency
                if (roundDisplay) {
                    roundDisplay.textContent = `Round ${currentRound}`;
                }

                // Update conclude round button based on round completion
                updateConcludeRoundButton();

                if (currentDrafterUid && currentTeams[currentDrafterUid]) {
                    const drafterTeamName = currentTeams[currentDrafterUid].name;
                    let drafterText = `<strong>${drafterTeamName}</strong> (Round ${draftRound}, Pick ${pickNumber})`;

                    if (currentDrafterUid === currentUser.uid) {
                        currentDrafterContainer.classList.add('my-turn');
                        drafterText += ' - <strong>Your Turn!</strong>';

                        // Show bank pick button when it's the user's turn and not round 1
                        if (bankPickBtn && currentRound > 1) {
                            bankPickBtn.classList.remove('hidden');
                        }
                    } else {
                        currentDrafterContainer.classList.remove('my-turn');

                        // Hide bank pick button when it's not the user's turn
                        if (bankPickBtn) {
                            bankPickBtn.classList.add('hidden');
                        }
                    }
                    currentDrafterName.innerHTML = drafterText; // Use innerHTML for bolding

                    // Update banked picks display
                    updateBankedPicksDisplay();

                } else {
                    // Check if we need to load team data for this UID
                    if (currentDrafterUid) {
                        // Try to load the team data if it's missing
                        const teamRef = ref(database, `leagues/${leagueId}/teams/${currentDrafterUid}`);
                        get(teamRef).then((snapshot) => {
                            if (snapshot.exists()) {
                                // Add the team to our local teams data
                                const teamData = snapshot.val();
                                currentTeams[currentDrafterUid] = teamData;
                                console.log("Loaded missing team data for:", currentDrafterUid);
                                
                                // Update UI now that we have the team data
                                updateDraftStatusUI(draftStatus);
                            } else {
                                console.warn("Current drafter UID not found in database:", currentDrafterUid);
                            }
                        }).catch(error => {
                            console.error("Error loading team data:", error);
                        });
                    }
                    
                    console.debug("Current drafter UID not in local teams data:", currentDrafterUid);
                    currentDrafterName.textContent = `Updating... (Round ${draftRound})`;
                    currentDrafterContainer.classList.remove('my-turn');

                    // Hide bank pick button
                    if (bankPickBtn) {
                        bankPickBtn.classList.add('hidden');
                    }
                }
            } else {
                // Draft is not active
                if (isCommissioner) {
                    startDraftBtn.classList.remove('hidden'); // Show start button if commissioner
                } else {
                    startDraftBtn.classList.add('hidden');
                }
                currentDrafterContainer.classList.add('hidden');
                currentDrafterName.textContent = 'Draft not started';
                currentDrafterContainer.classList.remove('my-turn');

                // Hide bank pick button
                if (bankPickBtn) {
                    bankPickBtn.classList.add('hidden');
                }
            }
        }

        // --- Firebase Listeners ---
        function setupLeagueListeners() {
            cleanupListeners(); // Clean up ALL old listeners first
            console.log(`Setting up listeners for league: ${leagueId}`);

            // Listener 1: Drafted Players changes
            const draftedPlayersRef = ref(database, `leagues/${leagueId}/draftedPlayers`);
            playerListeners.draftedPlayers = onValue(draftedPlayersRef, (snapshot) => {
                console.log("Drafted players data received.");
                const draftedData = snapshot.val() || {};
                // Sort by timestamp to determine draft order/number reliably
                draftedPlayers = Object.entries(draftedData)
                    .map(([key, player]) => ({ ...player, firebaseKey: key })) // Add firebaseKey
                    .sort((a, b) => (a.draftedAt || 0) > (b.draftedAt || 0) ? 1 : -1) // Sort by timestamp
                    .map((player, index) => ({ ...player, draftNumber: index + 1 })); // Assign draft number

                filterDraftedPlayers(); // Update 'Drafted Players' table
                filterPlayers(); // Re-filter available players
            }, (error) => {
                console.error("Error reading drafted players:", error);
                showNotification("Error loading drafted players list.", 7000);
            });
            console.log("Added drafted players listener.");

            // Listener 2: League Teams changes
            const teamsRef = ref(database, `leagues/${leagueId}/teams`);
            playerListeners.teams = onValue(teamsRef, (snapshot) => {
                console.log("Teams data received.");
                const newTeamsData = snapshot.val() || {};
                // Store basic user info from teams for chat/display efficiency
                const simplifiedTeams = {};
                Object.entries(newTeamsData).forEach(([uid, team]) => {
                    simplifiedTeams[uid] = {
                        name: team.name || `Team ${uid.substring(0, 4)}`,
                        isCommissioner: team.isCommissioner || false,
                        photoURL: team.owner?.photoURL || null // Get photo from owner profile if exists
                    };
                });

                detectJoinLeave(currentTeams, simplifiedTeams); // Detect presence changes based on simplified data
                currentTeams = simplifiedTeams; // Update global teams object

                populateTeamFilter(); // Update drafted players filter dropdown
                updateDraftStatusUI(leagueData?.draftStatus); // Refresh drafter name potentially
            }, (error) => {
                console.error("Error reading league teams:", error);
                showNotification("Error loading team information.", 7000);
            });
            console.log("Added teams listener.");

            // Listener 3: Chat messages
            const chatRef = ref(database, `leagues/${leagueId}/chat`);
            const chatQuery = query(chatRef, limitToLast(50)); // Load recent + listen for new
            chatListeners.chat = onValue(chatQuery, (snapshot) => {
                console.log("Chat data received.");
                updateChatMessages(snapshot.val() || {});
            }, (error) => {
                console.error("Error reading chat messages:", error);
                if (chatMessages) chatMessages.innerHTML = '<div class="chat-system error-message">Error loading chat messages.</div>';
            });
            console.log("Added chat listener.");

            // Listener 4: Eliminated Players
            const eliminatedPlayersRef = ref(database, `leagues/${leagueId}/eliminatedPlayers`);
            eliminatedPlayersListener = onValue(eliminatedPlayersRef, (snapshot) => {
                console.log("Eliminated players data received.");
                eliminatedPlayers = new Set();
                const eliminatedData = snapshot.val() || {};
                Object.entries(eliminatedData).forEach(([playerId, isEliminated]) => {
                    if (isEliminated === true) {
                        eliminatedPlayers.add(playerId);
                    }
                });
                console.log(`${eliminatedPlayers.size} eliminated players loaded.`);
                // Re-filter players to show eliminated status
                filterPlayers();
                filterDraftedPlayers();
                
                // Update the draft order display
                updateDraftOrderDisplay();
            }, (error) => {
                console.error("Error reading eliminated players:", error);
                showNotification("Error loading eliminated players list.", 7000);
            });
            console.log("Added eliminated players listener.");

            // Listener 5: Eliminated NHL Teams
            const eliminatedTeamsRef = ref(database, `leagues/${leagueId}/eliminatedNHLTeams`);
            eliminatedTeamsListener = onValue(eliminatedTeamsRef, (snapshot) => {
                console.log("Eliminated NHL teams data received.");
                eliminatedNHLTeams = new Set();
                const eliminatedData = snapshot.val() || {};
                Object.entries(eliminatedData).forEach(([teamCode, isEliminated]) => {
                    if (isEliminated === true) {
                        eliminatedNHLTeams.add(teamCode);
                    }
                });
                console.log(`${eliminatedNHLTeams.size} eliminated NHL teams loaded:`, Array.from(eliminatedNHLTeams));
                // Re-filter players to show eliminated teams
                filterPlayers();
                filterDraftedPlayers();
            }, (error) => {
                console.error("Error reading eliminated NHL teams:", error);
                showNotification("Error loading eliminated NHL teams list.", 7000);
            });
            console.log("Added eliminated NHL teams listener.");

            // Listener 5: Playoff Round Data
            const playoffRoundRef = ref(database, `leagues/${leagueId}/playoffRound`);
            playerListeners.playoffRound = onValue(playoffRoundRef, (snapshot) => {
                console.log("Playoff round data received.");
                const playoffData = snapshot.val() || {};
                const previousRound = currentRound; // Store previous round to detect changes
                currentRound = playoffData.currentRound || 1;
                bankedPicks = playoffData.bankedPicks || {};
                nextRoundDraftOrder = playoffData.nextRoundDraftOrder || [];

                console.log(`Current playoff round: ${currentRound}`);
                console.log(`Banked picks:`, bankedPicks);
                console.log(`Next round draft order:`, nextRoundDraftOrder);

                // Update UI to reflect current round
                if (roundDisplay) {
                    roundDisplay.textContent = `Round ${currentRound}`;
                }
                if (currentRoundNumber) {
                    currentRoundNumber.textContent = currentRound.toString();
                }

                // If the round has changed, reload player data for everyone
                if (previousRound !== currentRound) {
                    console.log(`Round changed from ${previousRound} to ${currentRound}, reloading player data...`);
                    // Clear existing player data to force reload
                    allPlayers = [];
                    // Reload with appropriate data for the new round
                    loadPlayerData();
                    // Show notification about the round change
                    showNotification(`Round ${currentRound} has started! Player stats updated.`, 5000);
                }

                // Update banked picks display if it's the current drafter's turn
                updateBankedPicksDisplay();
            }, (error) => {
                console.error("Error reading playoff round data:", error);
            });
            console.log("Added playoff round data listener.");

            // Listener 6: Online Presence (listen to a presence node)
            // Update user's own presence on connect/disconnect
            const presenceRef = ref(database, `leagues/${leagueId}/presence/${currentUser.uid}`);
            const connectedRef = ref(database, '.info/connected');
            playerListeners.presence = onValue(connectedRef, (snap) => {
                if (snap.val() === true) {
                    set(presenceRef, { online: true, lastSeen: serverTimestamp() });
                    // On disconnect, set presence to offline
                    onDisconnect(presenceRef).set({ online: false, lastSeen: serverTimestamp() });
                    console.log("User presence set to online.");
                }
            });
            console.log("Added presence listener.");

            // Listener 7: Draft Status (already set up in showDraftInterface, managed by draftStatusListener)
            
            // Initial update of draft order display
            updateDraftOrderDisplay();
        }

        function detectJoinLeave(previousTeams, newTeams) {
            if (!currentUser || Object.keys(previousTeams).length === 0) return; // Skip initial load

            const prevIds = new Set(Object.keys(previousTeams));
            const newIds = new Set(Object.keys(newTeams));

            newIds.forEach(uid => {
                if (!prevIds.has(uid) && uid !== currentUser.uid) {
                    const joinerName = newTeams[uid]?.name ?? 'Someone';
                    console.log(`${joinerName} detected joining.`);
                    addChatMessage({ type: 'system', text: `${joinerName} joined the draft`, timestamp: serverTimestamp() });
                }
            });

            prevIds.forEach(uid => {
                if (!newIds.has(uid) && uid !== currentUser.uid) { // Don't announce self leaving due to page close
                    const leaverName = previousTeams[uid]?.name ?? 'Someone';
                    console.log(`${leaverName} detected leaving.`);
                    // Don't announce leaves from here as it's often due to refresh/close. Rely on presence or explicit kick messages.
                    // addChatMessage({ type: 'system', text: `${leaverName} left the draft`, timestamp: serverTimestamp() });
                }
            });
        }

        // --- UI Updates ---
        function populateTeamFilter() {
            const currentFilterValue = draftedTeamFilter.value; // This might now be a UID or 'all'
            draftedTeamFilter.innerHTML = '<option value="all">All Teams</option>';

            if (currentTeams && Object.keys(currentTeams).length > 0) {
                // Sort teams by name for display
                const sortedTeamEntries = Object.entries(currentTeams)
                    .sort(([, teamA], [, teamB]) => (teamA.name || '').localeCompare(teamB.name || ''));

                sortedTeamEntries.forEach(([uid, team]) => {
                    // Use UID as value, Name as text content
                    const option = document.createElement('option');
                    option.value = uid; // Use the unique team UID as the value
                    option.textContent = team.name || `Unnamed Team (${uid.substring(0, 4)})`; // Display name
                    if (team.name) { // Only add if name is not empty
                        draftedTeamFilter.appendChild(option);
                    }
                });
            }

            // Try to restore previous selection (might be UID or 'all')
            const optionExists = [...draftedTeamFilter.options].some(opt => opt.value === currentFilterValue);
            if (optionExists) {
                draftedTeamFilter.value = currentFilterValue;
            } else if (currentUser && currentTeams[currentUser.uid]) {
                // Default to user's team UID if their previous selection isn't available
                draftedTeamFilter.value = currentUser.uid;
            } else {
                draftedTeamFilter.value = 'all'; // Default to all
            }

            // Make sure an option is actually selected if the user's UID wasn't found (edge case)
            if (draftedTeamFilter.selectedIndex === -1) {
                draftedTeamFilter.value = 'all';
            }

            filterDraftedPlayers(); // Refresh drafted players list with potentially new filter value
        }

        // --- Player Data Handling ---
        function loadPlayerData() {
            if (allPlayers && allPlayers.length > 0) {
                console.log("Player data already loaded.");
                filterPlayers(); return;
            }
            console.log("Loading player data...");
            if (playerTableBody) playerTableBody.innerHTML = `<tr><td colspan="10" style="text-align: center;"><div class="loader"></div></td></tr>`;

            // Determine which data source to use based on playoff round
            const dataSource = currentRound > 1 ? 'data/nhl_playoff_players.json' : 'data/nhl_players.json';
            console.log(`Loading player data from ${dataSource} (Round ${currentRound})`);

            fetch(dataSource)
                .then(response => {
                    // If the playoff data file isn't available yet, fall back to regular season
                    if (!response.ok && dataSource.includes('playoff')) {
                        console.log("Playoff stats not available yet, falling back to regular season stats");
                        return fetch('data/nhl_players.json');
                    }
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return response.json();
                })
                .then(data => {
                    if (!Array.isArray(data)) throw new Error("Player data is not an array.");
                    console.log(`Loaded ${data.length} players.`);
                    allPlayers = data;
                    filterPlayers(); // Initial display
                })
                .catch(error => {
                    console.error('Error loading player data:', error);
                    showNotification('Error loading NHL player data. Check console.', 7000);
                    if (playerTableBody) playerTableBody.innerHTML = `<tr><td colspan="10" style="text-align: center; color: red;">Failed to load player data. ${error.message}</td></tr>`;
                });
        }

        // --- Filtering & Rendering Players ---
        function filterPlayers() { // Filters and renders the AVAILABLE players table
            if (!allPlayers || allPlayers.length === 0 || !playerTableBody) return;

            const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
            const showDrafted = document.getElementById('showDrafted').checked;

            let filtered = allPlayers;

            // Apply position filter
            if (currentPositionFilter !== 'all') {
                filtered = filtered.filter(player => player.position === currentPositionFilter);
            }

            // Apply search filter
            if (searchTerm) {
                filtered = filtered.filter(player => (player.fullName || '').toLowerCase().includes(searchTerm));
            }

            // Get drafted player IDs and eliminated player IDs (ensure IDs are strings for comparison)
            const draftedIdsSet = new Set(draftedPlayers.map(dp => dp.playerId?.toString()));

            // In subsequent rounds, filter out eliminated players and players from eliminated teams
            // unless "Show Drafted" is checked
            if (currentRound > 1 && !showDrafted) {
                filtered = filtered.filter(player => {
                    // Check if the player ID is directly in the eliminated players set
                    const isPlayerEliminated = eliminatedPlayers.has(player.id?.toString());

                    // Check if the player's team is in the eliminated NHL teams set
                    const isTeamEliminated = eliminatedNHLTeams.has(player.teamAbbreviation);

                    // Keep the player if neither they nor their team is eliminated
                    return !isPlayerEliminated && !isTeamEliminated;
                });
            }

            // Filter out drafted unless 'Show Drafted' is checked
            if (!showDrafted) {
                filtered = filtered.filter(player => !draftedIdsSet.has(player.id?.toString()));
            }

            // Check if all picks for the round have been made - if so, disable drafting and show message to commissioner
            const draftStatus = leagueData?.draftStatus;
            const isRoundComplete = checkIfRoundComplete();
            if (isRoundComplete && draftStatus?.active) {
                // Show notification only once (using a session storage flag)
                const notificationKey = `round_complete_${leagueId}_${currentRound}`;
                if (!sessionStorage.getItem(notificationKey) && isCommissioner) {
                    sessionStorage.setItem(notificationKey, 'true');
                    showNotification("Round complete! Please click 'Conclude Round' to set up the next round.", 10000);
                }
            }

            // Apply sorting
            if (currentSortColumn) {
                filtered.sort((a, b) => {
                    let aValue = a[currentSortColumn];
                    let bValue = b[currentSortColumn];
                    const defaultStr = ''; const defaultNum = -Infinity; // Sort nulls/undefined low for numbers

                    if (typeof aValue === 'string' || typeof bValue === 'string') {
                        aValue = (aValue ?? defaultStr).toString().toLowerCase();
                        bValue = (bValue ?? defaultStr).toString().toLowerCase();
                        return currentSortDirection === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                    } else {
                        aValue = Number(aValue ?? defaultNum);
                        bValue = Number(bValue ?? defaultNum);
                        return currentSortDirection === 'asc' ? aValue - bValue : bValue - aValue;
                    }
                });
            } else { // Default sort by name
                filtered.sort((a, b) => (a.fullName || '').localeCompare(b.fullName || ''));
            }

            renderPlayerTable(filtered, draftedIdsSet);
        }

        function renderPlayerTable(playersToRender, draftedIdsSet) {
            if (!playerTableBody) return;
            playerTableBody.innerHTML = '';

            if (playersToRender.length === 0) {
                playerTableBody.innerHTML = `<tr><td colspan="10" style="text-align: center;">No players match filters.</td></tr>`;
                return;
            }

            const draftIsActive = leagueData?.draftStatus?.active ?? false;
            const isMyTurn = draftIsActive && leagueData?.draftStatus?.currentDrafter === currentUser?.uid;
            // Check commissioner mode toggle as well
            const iCanDraftAnyPlayer = draftIsActive && (isMyTurn || (isCommissioner && commissionerModeActive));

            const fragment = document.createDocumentFragment();

            playersToRender.forEach(player => {
                const row = document.createElement('tr');
                const playerIdStr = player.id?.toString();
                const isDrafted = draftedIdsSet.has(playerIdStr);
                // Check both individual player elimination and team elimination
                const isPlayerEliminated = eliminatedPlayers.has(playerIdStr);
                const isTeamEliminated = eliminatedNHLTeams.has(player.teamAbbreviation);
                const isEliminated = isPlayerEliminated || isTeamEliminated;

                // Apply classes for drafted and eliminated status
                row.classList.toggle('drafted', isDrafted);
                row.classList.toggle('eliminated-player', isEliminated);

                // Check if the round is complete (all picks made)
                const isRoundComplete = checkIfRoundComplete();

                // Button enabled if: I can draft *any* player AND this specific player is not drafted AND not eliminated AND round is not complete
                const draftButtonEnabled = iCanDraftAnyPlayer && !isDrafted && !isEliminated && !isRoundComplete;

                const formatStat = (val) => (val == null || val === "" || val === 0) ? '-' : val;
                const position = player.position || 'N/A';
                const fullName = player.fullName || 'N/A';
                const team = player.teamAbbreviation || 'N/A';

                // Use dataset for cleaner JS access
                row.dataset.playerId = playerIdStr;
                row.dataset.playerName = fullName;
                row.dataset.playerPosition = position;
                row.dataset.playerTeam = team;

                // Determine the elimination reason
                let eliminationLabel = '';
                if (isEliminated) {
                    if (isTeamEliminated) {
                        eliminationLabel = ` (Team Eliminated)`;
                    } else {
                        eliminationLabel = ` (Player Eliminated)`;
                    }
                }

                row.innerHTML = `
<td>${fullName}${eliminationLabel}</td>
<td>${position}</td>
<td>${team}${isTeamEliminated ? ' ❌' : ''}</td>
<td class="hide-mobile">${formatStat(player.gamesPlayed)}</td>
<td class="skater-stat">${position !== 'G' ? formatStat(player.goals) : '-'}</td>
<td class="skater-stat">${position !== 'G' ? formatStat(player.assists) : '-'}</td>
<td class="skater-stat">${position !== 'G' ? formatStat(player.points) : '-'}</td>
<td class="goalie-stat hide-mobile">${position === 'G' ? formatStat(player.wins) : '-'}</td>
<td class="goalie-stat hide-mobile">${position === 'G' ? formatStat(player.shutouts) : '-'}</td>
                    <td>
                        <button class="draft-button btn" ${draftButtonEnabled ? '' : 'disabled'}>
                            ${isDrafted ? 'Drafted' : (isEliminated ? 'Eliminated' : 'Draft')}
                        </button>
                    </td>
                `;
                fragment.appendChild(row);
            });

            playerTableBody.appendChild(fragment);

            // Add event listeners AFTER appending
            playerTableBody.querySelectorAll('.draft-button:not([disabled])').forEach(button => {
                // Remove potential old listeners before adding new ones
                button.removeEventListener('click', handleDraftClick);
                button.addEventListener('click', handleDraftClick);
            });
        }

        function handleDraftClick(event) {
            const button = event.target;
            const row = button.closest('tr'); // Get the parent row
            if (!row) return;

            // Disable button immediately
            button.disabled = true;
            button.textContent = 'Drafting...'; // Provide feedback

            const playerId = row.dataset.playerId;
            const playerName = row.dataset.playerName;
            const position = row.dataset.playerPosition;
            const nhlTeam = row.dataset.playerTeam;

            console.log(`Draft button clicked for ${playerName} (ID: ${playerId})`);
            draftPlayer(playerId, playerName, position, nhlTeam);
        }

        // --- Drafting Logic ---
        function draftPlayer(playerId, playerName, position, nhlTeam) {
            console.log(`Attempting draft for ${playerName}`);
            const draftIsActive = leagueData?.draftStatus?.active ?? false;
            if (!draftIsActive) {
                showNotification("The draft is not currently active.");
                filterPlayers(); // Refresh buttons
                return;
            }
            if (!currentUser) {
                showNotification("You must be logged in to draft.");
                filterPlayers();
                return;
            }

            const currentDrafterUid = leagueData.draftStatus.currentDrafter;
            const isMyTurn = currentDrafterUid === currentUser.uid;
            // Determine if commissioner mode allows drafting
            const commissionerDrafting = isCommissioner && commissionerModeActive;

            // Who is the pick assigned to?
            let teamUidToAssign = null;
            if (isMyTurn || commissionerDrafting) {
                // If it's my turn OR commissioner is overriding, the pick belongs to the *current* official drafter
                teamUidToAssign = currentDrafterUid;
            } else {
                showNotification("It's not your turn to draft.");
                filterPlayers(); // Re-enable button if wrongly disabled
                return;
            }

            const teamNameToAssign = currentTeams[teamUidToAssign]?.name;
            const drafterDisplayName = currentUser.displayName; // User performing the action

            if (!teamNameToAssign) {
                console.error(`Cannot assign player: Team name not found for UID ${teamUidToAssign}`);
                showNotification(`Error: Could not find team name for the current pick.`);
                filterPlayers();
                return;
            }

            // Check again if player already drafted (race condition mitigation)
            const latestDraftedIds = new Set(draftedPlayers.map(dp => dp.playerId?.toString()));
            if (latestDraftedIds.has(playerId?.toString())) {
                showNotification(`${playerName} has already been drafted.`);
                filterPlayers(); // Refresh table
                return;
            }

            // Get current draft state details for the record
            const currentRound = leagueData.draftStatus.round ?? 1;
            const currentPickNumber = leagueData.draftStatus.pickNumber ?? 1; // Overall pick number

            // Create player record
            const draftedPlayerRecord = {
                playerId: playerId,
                Player: playerName,
                Position: position,
                "NHL Team": nhlTeam,
                Team: teamNameToAssign, // Fantasy Team Name
                teamUid: teamUidToAssign, // UID of team getting the player
                draftedByUid: currentUser.uid, // UID of user clicking button
                draftedByName: drafterDisplayName, // Name of user clicking button
                draftedAt: serverTimestamp(), // Use server time for consistency
                round: currentRound,
                pickNumber: currentPickNumber // Store overall pick number
            };
            console.log("Drafted player record:", draftedPlayerRecord);

            disableAllDraftButtons(); // Prevent multiple clicks

            // Save to Firebase
            const draftedPlayersRef = ref(database, `leagues/${leagueId}/draftedPlayers`);
            const newPlayerRef = push(draftedPlayersRef);

            set(newPlayerRef, draftedPlayerRecord).then(() => {
                console.log(`${playerName} successfully drafted for ${teamNameToAssign}.`);
                showNotification(`${playerName} drafted! (Pick ${currentPickNumber})`);

                // Add system chat message
                let chatMessageText;
                if (!isMyTurn && commissionerDrafting) {
                    chatMessageText = `${drafterDisplayName} (Commish) drafted ${playerName} for ${teamNameToAssign} (Pick ${currentPickNumber})`;
                } else {
                    chatMessageText = `${teamNameToAssign} drafted ${playerName} (${position}, ${nhlTeam}) (Pick ${currentPickNumber})`;
                }
                addChatMessage({ type: 'system', text: chatMessageText, timestamp: serverTimestamp() });

                // Advance to the next drafter (Firebase function handles logic)
                moveToNextDrafter();

            }).catch((error) => {
                console.error(`Error drafting player ${playerName}:`, error);
                showNotification(`Error drafting player: ${error.message}`, 7000);
                filterPlayers(); // Re-enable buttons on error
            });
        }

        function disableAllDraftButtons() {
            playerTableBody.querySelectorAll('.draft-button').forEach(btn => {
                if (!btn.disabled) {
                    btn.disabled = true;
                    // Optionally change text: btn.textContent = 'Processing...';
                }
            });
        }

        // Filter and display the DRAFTED players list
        function filterDraftedPlayers() {
            if (!draftedTableBody) return;
            const teamFilter = draftedTeamFilter.value; // Filter by team UID now, or 'all'
            draftedTableBody.innerHTML = '';

            // Use the globally sorted and numbered draftedPlayers array
            let filtered = draftedPlayers;
            if (teamFilter !== 'all') {
                // Filter by the teamUid property of the drafted player object
                filtered = filtered.filter(player => player.teamUid === teamFilter);
            }

            const fragment = document.createDocumentFragment();

            if (filtered.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = `<td colspan="6" style="text-align: center;">${teamFilter === 'all' ? 'No players drafted yet.' : 'No players drafted for this team yet.'}</td>`;
                fragment.appendChild(row);
            } else {
                // Determine the key of the last drafted player (highest pick number, or last in timestamp-sorted array)
                // The global `draftedPlayers` is already sorted by pickNumber (via timestamp).
                const lastDraftedPlayer = draftedPlayers.length > 0 ? draftedPlayers[draftedPlayers.length - 1] : null;
                const lastDraftedPlayerKey = lastDraftedPlayer?.firebaseKey;

                filtered.forEach((player) => { // 'filtered' here depends on the team dropdown selection
                    const row = document.createElement('tr');

                    // Check both individual player elimination and team elimination
                    const playerId = player.playerId?.toString();
                    const teamCode = player["NHL Team"]; // This should be the team abbreviation

                    const isPlayerEliminated = eliminatedPlayers.has(playerId);
                    const isTeamEliminated = eliminatedNHLTeams.has(teamCode);
                    const isEliminated = isPlayerEliminated || isTeamEliminated;

                    if (isEliminated) {
                        row.classList.add('eliminated-player');
                    }

                    // Determine if *this* player is the absolute last pick overall
                    const isOverallLastPick = player.firebaseKey === lastDraftedPlayerKey;
                    // Button is shown only if commissioner AND this player is the overall last pick
                    const canUndo = isCommissioner && isOverallLastPick;

                    // Get draft round info
                    const draftRound = player.round || 1;

                    // Determine the elimination reason
                    let eliminationLabel = '';
                    if (isEliminated) {
                        if (isTeamEliminated) {
                            eliminationLabel = ` (Team Eliminated)`;
                        } else if (isPlayerEliminated) {
                            eliminationLabel = ` (Player Eliminated)`;
                        }
                    }

                    // Check if this is a banked pick (not a real player)
                    const isBankedPick = player.isBankedPick === true;

                    if (isBankedPick) {
                        // Special styling for banked picks
                        row.classList.add('banked-pick-row');
                        row.style.backgroundColor = '#e8f4ff';

                        row.innerHTML = `
                            <td style="width: 5%; text-align: center;">${player.draftNumber || '-'}</td>
                            <td><strong>BANKED PICK</strong> (Saved for future round)</td>
                            <td>-</td>
                            <td class="hide-mobile">-</td>
                            <td>${player.Team || 'N/A'}<span class="round-indicator" style="font-size: 0.7em; padding: 1px 4px;">R${draftRound}</span></td>
                            <td>
                                ${canUndo ? `<button class="undo-banked-pick-button btn danger" data-key="${player.firebaseKey}">Undo Bank</button>` : ''}
                            </td>
                        `;
                    } else {
                        // Regular player pick
                        row.innerHTML = `
                            <td style="width: 5%; text-align: center;">${player.draftNumber || '-'}</td>
                            <td>${player.Player || 'N/A'}${eliminationLabel}</td>
                            <td>${player.Position || 'N/A'}</td>
                            <td class="hide-mobile">${player["NHL Team"] || 'N/A'}${isTeamEliminated ? ' ❌' : ''}</td>
                            <td>${player.Team || 'N/A'}<span class="round-indicator" style="font-size: 0.7em; padding: 1px 4px;">R${draftRound}</span></td>
                            <td>
                                ${canUndo ? `<button class="undo-button btn danger" data-key="${player.firebaseKey}">Undo Pick</button>` : ''}
                            </td>
                        `;
                    }
                    fragment.appendChild(row);
                });
            }
            draftedTableBody.appendChild(fragment);

            // Add event listeners to undo buttons AFTER they're in the DOM
            draftedTableBody.querySelectorAll('.undo-button').forEach(button => {
                button.removeEventListener('click', handleUndoClick); // Remove any existing handlers
                button.addEventListener('click', handleUndoClick);
            });

            // Add event listeners to undo banked pick buttons
            draftedTableBody.querySelectorAll('.undo-banked-pick-button').forEach(button => {
                button.removeEventListener('click', handleUndoBankedPickClick); // Remove any existing handlers
                button.addEventListener('click', handleUndoBankedPickClick);
            });
        }

        function handleUndoClick(event) {
            const button = event.target;
            const key = button.dataset.key;
            const row = button.closest('tr');
            if (!key || !row) return;

            // Get data from the row cells to use in the undo function
            const pickNumber = parseInt(row.cells[0].textContent) || 0;
            const playerName = row.cells[1].textContent;

            // Find the full player data from our global array
            const playerData = draftedPlayers.find(p => p.firebaseKey === key);
            if (!playerData) {
                console.error("Could not find player data for key:", key);
                showNotification("Error: Could not find player data");
                return;
            }

            // Call the undo function with the complete data
            undoLastDraftPick(
                key,
                playerName,
                pickNumber,
                playerData.round || 1,
                playerData.teamUid,
                playerData.Team
            );
        }

        // --- Draft Control (Start, Advance) ---
        function startDraft() {
            if (!isCommissioner) {
                showNotification("Only the commissioner can start the draft."); return;
            }

            const teamUids = Object.keys(currentTeams || {});
            if (teamUids.length < 2) { // Require at least 2 teams
                showNotification("Need at least 2 teams to start a draft."); return;
            }

            // Debug info about teams before randomization
            console.log("Teams before randomization:");
            teamUids.forEach(uid => {
                console.log(`- ${uid}: ${currentTeams[uid].name} ${uid === currentUser.uid ? '(Commissioner)' : ''}`);
            });

            if (!confirm(`Start the draft for "${leagueData?.name ?? 'this league'}"? Draft order will be randomized.`)) {
                return;
            }
            console.log("Commissioner starting draft...");

            // Reset round to 1 and pick number to 1 to ensure we start fresh
            currentRound = 1;

            // Enhanced Fisher-Yates shuffle with more entropy
            let draftOrder = [...teamUids];

            // Add extra randomness - do multiple shuffles
            for (let shuffle = 0; shuffle < 3; shuffle++) {
                for (let i = draftOrder.length - 1; i > 0; i--) {
                    // Use a more complex random seed
                    const randomSeed = Math.random() * Date.now() % 10000;
                    const j = Math.floor(randomSeed % (i + 1));
                    [draftOrder[i], draftOrder[j]] = [draftOrder[j], draftOrder[i]];
                }
            }

            // Debug the results of randomization
            console.log("Randomized draft order:");
            draftOrder.forEach((uid, index) => {
                console.log(`${index + 1}: ${currentTeams[uid].name} ${uid === currentUser.uid ? '(Commissioner)' : ''}`);
            });

            // Log commissioner position for verification
            const commissionerIndex = draftOrder.indexOf(currentUser.uid);
            console.log(`Commissioner is position ${commissionerIndex + 1} out of ${draftOrder.length}`);

            // Set initial draft status
            const initialDraftStatus = {
                active: true,
                startedAt: serverTimestamp(),
                startedByUid: currentUser.uid,
                draftOrder: draftOrder,
                currentDrafter: draftOrder[0], // First pick
                round: 1,
                pickNumber: 1, // Overall pick number
                randomizationTime: Date.now(), // Add this for audit/debug
                snakeDraft: true // Enable snake draft style
            };

            // Also set playoff round data to ensure round is set to 1
            const playoffRoundData = {
                currentRound: 1,
                bankedPicks: {},
                nextRoundDraftOrder: []
            };

            // Save to Firebase - use update to update multiple nodes atomically
            const updates = {};
            updates[`leagues/${leagueId}/draftStatus`] = initialDraftStatus;
            updates[`leagues/${leagueId}/playoffRound`] = playoffRoundData;

            const dbRef = ref(database);
            update(dbRef, updates).then(() => {
                console.log("Draft status set, draft started.");
                const firstDrafterName = currentTeams[draftOrder[0]]?.name ?? 'First Pick';
                const startMessage = `Draft started by ${currentUser.displayName}! Draft order randomized. ${firstDrafterName} is up first.`;
                addChatMessage({ type: 'system', text: startMessage, timestamp: serverTimestamp() });
                showNotification("Round 1 started!");

                // Force a reload of player data
                allPlayers = [];
                loadPlayerData();

                // UI updates handled by onValue listener
            }).catch((error) => {
                console.error("Error starting draft:", error);
                showNotification(`Error starting draft: ${error.message}`, 7000);
            });
        }

        function moveToNextDrafter() {
            // Guard clauses
            if (!leagueData?.draftStatus?.draftOrder || !leagueData.draftStatus.currentDrafter) {
                console.error("Cannot move to next drafter: Missing draft status data.");
                showNotification("Error: Could not determine next drafter.", 7000);
                return;
            }

            const { draftOrder, currentDrafter, round, pickNumber } = leagueData.draftStatus;
            const currentIndex = draftOrder.indexOf(currentDrafter);
            const numTeams = draftOrder.length;

            if (currentIndex === -1) {
                console.error("Critical Error: Current drafter not found in order!");
                showNotification("Error: Draft order corrupted. Draft paused.", 10000);
                // Consider pausing: update(ref(database, `leagues/${leagueId}/draftStatus`), { active: false });
                return;
            }

            // Calculate next index, round, and pick number (Snake Draft)
            let nextIndex;
            let nextRound = round;
            let nextPickNumber = (pickNumber || 0) + 1; // Increment overall pick
            
            // Determine if we're going forward or backward in this round (Snake Draft)
            const isEvenRound = round % 2 === 0;
            
            if (isEvenRound) {
                // Even rounds go in reverse order (right to left)
                nextIndex = currentIndex - 1;
                
                if (nextIndex < 0) {
                    // Reached the beginning of an even round, go to first position of the next round
                    nextIndex = 0;
                    nextRound++;
                    console.log(`Reached beginning of round ${round}, starting round ${nextRound} at first position`);
                }
            } else {
                // Odd rounds go in normal order (left to right)
                nextIndex = currentIndex + 1;
                
                if (nextIndex >= numTeams) {
                    // Reached the end of an odd round, go to last position of the next round
                    nextIndex = numTeams - 1;
                    nextRound++;
                    console.log(`Reached end of round ${round}, starting round ${nextRound} at last position`);
                }
            }

            const nextDrafterUid = draftOrder[nextIndex];
            console.log(`Next pick: ${nextDrafterUid}, Round: ${nextRound}, Pick#: ${nextPickNumber}, Direction: ${isEvenRound ? 'Reverse' : 'Forward'}`);

            // Update Firebase
            const draftStatusRef = ref(database, `leagues/${leagueId}/draftStatus`);
            update(draftStatusRef, {
                currentDrafter: nextDrafterUid,
                round: nextRound,
                pickNumber: nextPickNumber
            }).then(() => {
                console.log("Draft status updated for next turn.");
                // Announce in chat (handled by onValue listener reacting to change, avoid double messages)
                const nextDrafterName = currentTeams[nextDrafterUid]?.name ?? 'Next Drafter';
                // Add slight delay? Or just rely on listener? Rely on listener for now.
                // addChatMessage({ type: 'system', text: `It's now ${nextDrafterName}'s turn (Pick ${nextPickNumber})` });

                // Check if this completes the round and update conclude button
                if (nextPickNumber > draftOrder.length && isCommissioner) {
                    // All picks completed - update conclude round button
                    updateConcludeRoundButton();
                }

                // Show notification if it's my turn now
                if (nextDrafterUid === currentUser?.uid) {
                    showNotification("It's your turn to draft!", 7000);
                }
            }).catch((error) => {
                console.error("Error updating draft status for next turn:", error);
                showNotification(`Error advancing draft turn: ${error.message}`, 7000);
                filterPlayers(); // Try re-enabling buttons if failed
            });
        }

        // --- Event Listeners for Filters & Sorting ---
        document.querySelectorAll('.position-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.position-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentPositionFilter = btn.dataset.position;
                filterPlayers(); // Re-filter available players
            });
        });

        document.querySelectorAll('th[data-sort]').forEach(header => {
            header.addEventListener('click', () => {
                const columnKey = header.dataset.sort;
                const table = header.closest('table');
                if (!table || !columnKey) return;

                const isPlayerTable = table.id === 'playerTable';
                let sortDirection;

                if (header.classList.contains('sorted-asc')) {
                    sortDirection = 'desc';
                } else {
                    sortDirection = 'asc'; // Default asc
                }

                // Update classes on clicked header
                table.querySelectorAll('th[data-sort]').forEach(h => h.classList.remove('sorted-asc', 'sorted-desc'));
                header.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                console.log(`Sorting table '${table.id}' by '${columnKey}' ${sortDirection}`);

                if (isPlayerTable) {
                    currentSortColumn = columnKey;
                    currentSortDirection = sortDirection;
                    filterPlayers(); // filterPlayers applies sorting
                } else {
                    sortAndRenderDraftedTable(columnKey, sortDirection); // Sort local drafted array
                }
            });
        });

        function sortAndRenderDraftedTable(columnKey, direction) {
            // Sort the global draftedPlayers array based on the column key and direction
            draftedPlayers.sort((a, b) => {
                let aValue = a[columnKey];
                let bValue = b[columnKey];
                const defaultStr = '';
                // Sort 'Pick#' (draftNumber) numerically, others potentially alphabetically
                const isNumericSort = columnKey === 'draftNumber';
                const defaultNum = direction === 'asc' ? Infinity : -Infinity; // Sort nulls appropriately

                if (isNumericSort) {
                    aValue = Number(aValue ?? defaultNum);
                    bValue = Number(bValue ?? defaultNum);
                    return direction === 'asc' ? aValue - bValue : bValue - aValue;
                } else { // Assume string sort for others
                    aValue = (aValue ?? defaultStr).toString().toLowerCase();
                    bValue = (bValue ?? defaultStr).toString().toLowerCase();
                    return direction === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
            });
            // Re-render the drafted table using the now-sorted global array
            filterDraftedPlayers();
        }

        // --- Chat Functionality ---
        function setupChat() {
            if (!chatContainer || !chatHeader || !chatToggle || !chatSend || !chatInput) return;
            chatHeader.addEventListener('click', (e) => { if (e.target !== chatToggle) toggleChatWindow(); });
            chatToggle.addEventListener('click', toggleChatWindow);
            chatSend.addEventListener('click', sendChatMessage);
            chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChatMessage(); } });
        }

        function toggleChatWindow() {
            const isMinimized = chatContainer.classList.toggle('minimized');
            chatToggle.textContent = isMinimized ? '+' : '−'; // Use minus sign
            if (!isMinimized) scrollToChatBottom(true); // Scroll on open
        }

        function sendChatMessage() {
            const messageText = chatInput.value.trim();
            if (!messageText || !currentUser || !leagueId) return;

            addChatMessage({
                type: 'user',
                uid: currentUser.uid,
                name: currentTeams[currentUser.uid]?.name || currentUser.displayName || 'User', // Prefer team name
                photoURL: currentTeams[currentUser.uid]?.photoURL || currentUser.photoURL || null, // Prefer team photo
                text: messageText,
                timestamp: serverTimestamp()
            });
            chatInput.value = '';
            // chatInput.focus(); // Maybe annoying on mobile
        }

        function addChatMessage(messageObject) {
            if (!leagueId) return;
            const chatRef = ref(database, `leagues/${leagueId}/chat`);
            push(chatRef, messageObject).catch(error => {
                console.error("Error sending chat message:", error);
                showNotification(`Error sending message: ${error.message}`, 7000);
            });
        }

        function updateChatMessages(messagesObject) {
            if (!chatMessages) return;
            const shouldScroll = chatMessages.scrollHeight - chatMessages.clientHeight <= chatMessages.scrollTop + 50;
            chatMessages.innerHTML = ''; // Clear and rebuild (simpler for limited history)
            const fragment = document.createDocumentFragment();

            const sortedKeys = Object.keys(messagesObject).sort((keyA, keyB) =>
                (messagesObject[keyA]?.timestamp ?? 0) - (messagesObject[keyB]?.timestamp ?? 0)
            );

            sortedKeys.forEach(key => {
                const message = messagesObject[key];
                if (!message || !message.text) return; // Skip empty

                const messageEl = document.createElement('div');
                const sanitize = (str) => (str || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

                if (message.type === 'system') {
                    messageEl.className = 'chat-system';
                    messageEl.textContent = sanitize(message.text);
                } else {
                    messageEl.className = 'chat-message';
                    // Format timestamp (locale-specific)
                    const timeStr = message.timestamp ? new Date(message.timestamp).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' }) : '';

                    const safeName = sanitize(message.name || 'User');
                    const safeText = sanitize(message.text);
                    const avatarImg = message.photoURL
                        ? `<img src="${sanitize(message.photoURL)}" alt="" class="user-avatar">`
                        : `<span class="user-avatar" style="background-color: ${getUserColor(message.uid)};"></span>`; // Placeholder with color hash

                    messageEl.innerHTML = `
                        <div class="chat-user">
                            ${avatarImg}
                            <strong>${safeName}</strong>
                            <span class="chat-time">${timeStr}</span>
                        </div>
                        <div class="chat-text">${safeText.replace(/\n/g, '<br>')}</div> <!-- Allow line breaks -->
                    `;
                }
                fragment.appendChild(messageEl);
            });
            chatMessages.appendChild(fragment);
            if (shouldScroll) scrollToChatBottom(true); // Force scroll if was at bottom
        }

        // Simple hash function for placeholder color
        function getUserColor(uid) {
            let hash = 0;
            for (let i = 0; i < (uid?.length || 0); i++) {
                hash = uid.charCodeAt(i) + ((hash << 5) - hash);
            }
            const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
            return "#" + "00000".substring(0, 6 - c.length) + c;
        }

        function scrollToChatBottom(force = false) {
            if (!chatMessages) return;
            const scrollTolerance = 50;
            if (force || chatMessages.scrollHeight - chatMessages.clientHeight <= chatMessages.scrollTop + scrollTolerance) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }

        // --- Helper Functions ---
        function setupAuthPersistence() {
            // Handled by Firebase SDK setting: browserSessionPersistence
        }

        function handleNoAccessToLeague(leagueDataToShow) {
            resetUIState();
            leagueSelectContainer.classList.remove('hidden'); // Show selection area

            const leagueName = leagueDataToShow?.name ?? 'this league';
            const teams = leagueDataToShow?.teams || {};
            const teamUids = Object.keys(teams);
            const currentUid = currentUser?.uid || 'unknown';

            console.warn(`Access denied. User UID: ${currentUid}`);
            console.warn(`League Teams:`, teamUids);

            if (leagueListEl) {
                leagueListEl.innerHTML = `
                    <div class="card" style="border-color: #dc3545;">
                        <h2>Access Denied</h2>
                        <p>You are not a member of "${leagueName}".</p>
                        <p>Your account (${currentUser?.email}) is not listed under the league's teams.</p>
                        <p>If this is unexpected, ensure you're signed in with the correct Google account or rejoin from the Manage Leagues page.</p>
                        <a href="manage-leagues.html" class="btn secondary">Go to Manage Leagues</a>
                    </div>`;
            }

            cleanupListeners();
            leagueId = null;
        }


        function showNotification(message, duration = 5000) {
            const existing = document.querySelector('.notification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            document.body.appendChild(notification);
            console.log(`Notify: ${message}`);

            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500); // Remove after fade
            }, duration - 500);
        }

        function updateBankedPicksDisplay() {
            if (!bankedPicks || !currentUser) return;

            // Get the number of banked picks for the current user
            const myBankedPicks = bankedPicks[currentUser.uid] || 0;

            // Get the current drafter UID
            const currentDrafterUid = leagueData?.draftStatus?.currentDrafter;

            // Show banked picks info if it's the current user's turn
            if (currentDrafterUid === currentUser.uid) {
                if (myBankedPicks > 0) {
                    // User has banked picks
                    bankedPicksInfo.classList.remove('hidden');
                    currentTeamBankedPicks.textContent = myBankedPicks;
                } else {
                    // User doesn't have banked picks
                    bankedPicksInfo.classList.add('hidden');
                }

                // Show bank pick button if it's the user's turn
                bankPickBtn.classList.remove('hidden');
            } else {
                // Not the user's turn
                bankedPicksInfo.classList.add('hidden');
                bankPickBtn.classList.add('hidden');
            }
        }
        
        // Display the current draft order
        function updateDraftOrderDisplay() {
            const draftOrderDisplay = document.getElementById('draft-order-display');
            if (!draftOrderDisplay) return;
            
            // Clear existing content
            draftOrderDisplay.innerHTML = '';
            
            if (!leagueData || !leagueData.draftStatus || !leagueData.draftStatus.draftOrder) {
                draftOrderDisplay.innerHTML = '<div class="empty-message">Draft order not set yet</div>';
                return;
            }
            
            const draftOrder = leagueData.draftStatus.draftOrder || [];
            const currentRound = leagueData.draftStatus.round || 1;
            const currentPickIndex = (leagueData.draftStatus.pickNumber || 1) - 1;
            const currentDrafterUid = leagueData.draftStatus.currentDrafter;
            const isEvenRound = currentRound % 2 === 0;
            
            // Create a label to show the snake draft direction
            const directionLabel = document.createElement('div');
            directionLabel.className = 'draft-direction-label';
            directionLabel.innerHTML = `Round ${currentRound}: ${isEvenRound ? '← Reverse Order' : '→ Normal Order'}`;
            draftOrderDisplay.appendChild(directionLabel);
            
            // Create container for the draft order items
            const orderContainer = document.createElement('div');
            orderContainer.className = 'draft-order-items';
            draftOrderDisplay.appendChild(orderContainer);
            
            // Create a team item for each team in the draft order
            // Display teams based on their original order, but highlight the actual next drafter
            draftOrder.forEach((teamUid, index) => {
                const team = currentTeams[teamUid];
                if (!team) return; // Skip if team not found
                
                const orderItem = document.createElement('div');
                orderItem.className = 'draft-order-item';
                
                // Mark current team's turn
                const currentIndex = draftOrder.indexOf(currentDrafterUid);
                if (index === currentIndex) {
                    orderItem.classList.add('current');
                }
                
                // Mark your team
                if (teamUid === currentUser?.uid) {
                    orderItem.style.borderColor = '#4caf50';
                    orderItem.style.borderWidth = '2px';
                }
                
                // Add banked pick indicator if applicable
                const teamBankedPicks = bankedPicks[teamUid] || 0;
                const bankedPicksIndicator = teamBankedPicks > 0 
                    ? `<span class="banked-pick-indicator">${teamBankedPicks} Banked</span>` 
                    : '';
                
                // Add snake draft position indicators for each round
                let roundPositions = '';
                for (let r = 1; r <= 4; r++) {
                    // Calculate position in each round
                    let positionInRound = r % 2 === 0 
                        ? draftOrder.length - index  // Even rounds: reverse order
                        : index + 1;                 // Odd rounds: normal order
                    
                    roundPositions += `<span class="round-position ${r === currentRound ? 'current-round' : ''}">R${r}: #${positionInRound}</span>`;
                }
                
                orderItem.innerHTML = `
                    <span class="draft-order-number">${index + 1}</span>
                    <div class="draft-order-details">
                        <span class="draft-order-name">${team.name}</span>
                        <div class="draft-order-positions">${roundPositions}</div>
                    </div>
                    ${bankedPicksIndicator}
                `;
                
                orderContainer.appendChild(orderItem);
            });
            
            if (draftOrder.length === 0) {
                orderContainer.innerHTML = '<div class="empty-message">Draft order not set yet</div>';
            }
            
            // Add CSS for the new elements
            const style = document.createElement('style');
            style.textContent = `
                .draft-direction-label {
                    font-weight: bold;
                    margin-bottom: 10px;
                    color: var(--primary-color);
                    background-color: #f0f4f8;
                    padding: 5px 10px;
                    border-radius: 5px;
                    text-align: center;
                }
                .draft-order-items {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 10px;
                    align-items: stretch;
                }
                .draft-order-item {
                    flex: 1 0 200px;
                    display: flex;
                    align-items: center;
                    padding: 10px;
                }
                .draft-order-details {
                    flex: 1;
                    margin-left: 10px;
                }
                .draft-order-positions {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 5px;
                    margin-top: 5px;
                    font-size: 0.75rem;
                }
                .round-position {
                    background-color: #f0f0f0;
                    padding: 2px 5px;
                    border-radius: 3px;
                    color: #666;
                }
                .round-position.current-round {
                    background-color: var(--primary-color);
                    color: white;
                    font-weight: bold;
                }
                @media (max-width: 768px) {
                    .draft-order-items {
                        flex-direction: column;
                    }
                    .draft-order-item {
                        width: 100%;
                        flex-basis: auto;
                    }
                }
            `;
            document.head.appendChild(style);
        }

        function cleanupListeners() {
            console.log("Cleaning up Firebase listeners...");
            let cleanedCount = 0;
            const cleanup = (listenersObj, type) => {
                Object.entries(listenersObj).forEach(([key, unsubscribe]) => {
                    if (typeof unsubscribe === 'function') {
                        try { unsubscribe(); console.log(` - Unsubscribed from ${type}: ${key}`); cleanedCount++; }
                        catch (e) { console.error(`Error unsubscribing ${type} ${key}:`, e); }
                    }
                });
                return {}; // Return empty object
            };
            playerListeners = cleanup(playerListeners, 'player listener');
            chatListeners = cleanup(chatListeners, 'chat listener');

            // Clean up draft status listener
            if (draftStatusListener && leagueId) {
                try {
                    const draftStatusRef = ref(database, `leagues/${leagueId}/draftStatus`);
                    off(draftStatusRef, 'value', draftStatusListener); // Correct Firebase V9 way
                    console.log(" - Unsubscribed from draft status listener.");
                    cleanedCount++;
                } catch (e) { console.error("Error unsubscribing draft status listener:", e); }
                draftStatusListener = null;
            }

            // Clean up eliminated players listener
            if (eliminatedPlayersListener && leagueId) {
                try {
                    const eliminatedPlayersRef = ref(database, `leagues/${leagueId}/eliminatedPlayers`);
                    off(eliminatedPlayersRef, 'value', eliminatedPlayersListener);
                    console.log(" - Unsubscribed from eliminated players listener.");
                    cleanedCount++;
                } catch (e) { console.error("Error unsubscribing eliminated players listener:", e); }
                eliminatedPlayersListener = null;
            }

            // Clean up eliminated NHL teams listener
            if (eliminatedTeamsListener && leagueId) {
                try {
                    const eliminatedTeamsRef = ref(database, `leagues/${leagueId}/eliminatedNHLTeams`);
                    off(eliminatedTeamsRef, 'value', eliminatedTeamsListener);
                    console.log(" - Unsubscribed from eliminated NHL teams listener.");
                    cleanedCount++;
                } catch (e) { console.error("Error unsubscribing eliminated NHL teams listener:", e); }
                eliminatedTeamsListener = null;
            }

            // Clean up presence listener (handled by Firebase on disconnect)
            window.removeEventListener('beforeunload', handlePageLeave);
            console.log(`Cleanup complete. ${cleanedCount} listeners removed.`);
        }

        // --- Global Access & DOM Ready ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Ready.");
            setupChat();
            // Initial state check (wait for auth)
            if (leagueId && !currentUser) console.log("League ID found, waiting for auth...");
        });

        // Handle the bank pick button click
        function handleBankPick() {
            // Check if we're past round 1
            if (currentRound <= 1) {
                showNotification("Banking picks is only available after the first round.");
                return;
            }

            // Check if round is already complete
            if (checkIfRoundComplete()) {
                showNotification("This round is already complete. The commissioner needs to conclude it.");
                return;
            }

            // Check if it's actually the user's turn
            const currentDrafterUid = leagueData?.draftStatus?.currentDrafter;

            if (currentDrafterUid !== currentUser.uid && !commissionerModeActive) {
                showNotification("You can only bank picks during your turn.");
                return;
            }

            // Confirm before banking
            if (!confirm("Are you sure you want to bank this pick for a future round? You will skip this pick and gain an extra pick in a later round.")) {
                return;
            }

            // Disable the bank pick button to prevent double-clicks
            bankPickBtn.disabled = true;

            // Get current banked picks for this team
            const teamUid = currentDrafterUid;
            const currentBankedPicks = bankedPicks[teamUid] || 0;
            const drafterTeamName = currentTeams[teamUid]?.name || "Unknown Team";

            // Create a banked pick record to add to draftedPlayers
            const bankedPickRecord = {
                isBankedPick: true, // Flag to identify this as a banked pick, not a player
                teamUid: teamUid,
                Team: drafterTeamName,
                Player: "BANKED PICK", // Placeholder for display
                Position: "-",
                "NHL Team": "-",
                draftedByUid: currentUser.uid,
                draftedByName: currentUser.displayName,
                draftedAt: serverTimestamp(),
                round: currentRound,
                pickNumber: leagueData.draftStatus.pickNumber || 1
            };

            // Prepare updates
            const updates = {};

            // Increment banked picks counter
            updates[`leagues/${leagueId}/playoffRound/bankedPicks/${teamUid}`] = currentBankedPicks + 1;

            // Add a chat message
            const chatMessage = {
                type: 'system',
                text: `${drafterTeamName} banked their pick for a future round.`,
                timestamp: serverTimestamp()
            };

            // Add the banked pick record to draftedPlayers
            const draftedPlayersRef = ref(database, `leagues/${leagueId}/draftedPlayers`);
            const newBankedPickRef = push(draftedPlayersRef);

            // First add the banked pick record
            set(newBankedPickRef, bankedPickRecord)
                .then(() => {
                    console.log(`Banked pick recorded for team ${drafterTeamName}`);

                    // Then update the banked picks counter
                    return update(ref(database), updates);
                })
                .then(() => {
                    console.log(`Pick banked for team ${drafterTeamName}`);
                    showNotification(`Pick banked for future round`);

                    // Add chat message
                    addChatMessage(chatMessage);

                    // Move to next drafter - this skips the current pick
                    moveToNextDrafter();

                    // Update conclude round button if this completes the round
                    updateConcludeRoundButton();

                    // Re-enable the button
                    bankPickBtn.disabled = false;
                })
                .catch((error) => {
                    console.error("Error banking pick:", error);
                    showNotification(`Error banking pick: ${error.message}`, 7000);
                    bankPickBtn.disabled = false;
                });
        }

        // Handle undoing a banked pick
        function handleUndoBankedPickClick(event) {
            const button = event.target;
            const key = button.dataset.key;
            const row = button.closest('tr');
            if (!key || !row) return;

            // Find the banked pick data from our global array
            const bankedPickData = draftedPlayers.find(p => p.firebaseKey === key);
            if (!bankedPickData || !bankedPickData.isBankedPick) {
                console.error("Could not find banked pick data or this is not a banked pick:", key);
                showNotification("Error: Could not find banked pick data");
                return;
            }

            // Get team UID for this banked pick
            const teamUid = bankedPickData.teamUid;
            const teamName = bankedPickData.Team || 'Unknown Team';
            const pickNumber = bankedPickData.draftNumber || 0;

            // Confirm the action
            if (!confirm(`Are you sure you want to undo banked pick #${pickNumber} for ${teamName}? This will revert the draft to this point and decrement this team's banked pick count.`)) {
                return;
            }

            // Prepare atomic updates
            const updates = {};

            // 1. Remove the banked pick entry
            updates[`leagues/${leagueId}/draftedPlayers/${key}`] = null;

            // 2. Decrement the banked picks count for this team
            const currentBankedPicks = bankedPicks[teamUid] || 0;
            if (currentBankedPicks > 0) {
                updates[`leagues/${leagueId}/playoffRound/bankedPicks/${teamUid}`] = currentBankedPicks - 1;
            }

            // 3. Revert the draft state - same as undoing a regular pick
            updates[`leagues/${leagueId}/draftStatus/currentDrafter`] = teamUid;
            updates[`leagues/${leagueId}/draftStatus/pickNumber`] = pickNumber;

            // Execute atomic update
            const dbRef = ref(database);
            update(dbRef, updates).then(() => {
                console.log(`Banked pick #${pickNumber} for ${teamName} undone successfully.`);
                showNotification(`Banked pick undone. It's now ${teamName}'s turn again.`);
                addChatMessage({
                    type: 'system',
                    text: `${currentUser.displayName} (Commish) undid banked pick #${pickNumber} by ${teamName}.`,
                    timestamp: serverTimestamp()
                });
                // Data updates via onValue listener will refresh UI
            }).catch(error => {
                console.error(`Error undoing banked pick #${pickNumber}:`, error);
                showNotification(`Error undoing banked pick: ${error.message}`, 7000);
            });
        }

        // Make functions globally accessible for inline HTML calls
        window.draftPlayer = draftPlayer;
        window.filterPlayers = filterPlayers;
        window.filterDraftedPlayers = filterDraftedPlayers;
        window.handleUndoClick = handleUndoClick;
        window.handleUndoBankedPickClick = handleUndoBankedPickClick;

        // Undo the last draft pick (Commissioner only)
        function undoLastDraftPick(firebaseKey, playerNameForMessage, pickNumberToUndo, roundToRestore, teamUidToRestore, teamNameToRestore) {
            if (!isCommissioner) {
                showNotification("Only the commissioner can undo draft picks.");
                return;
            }

            if (!firebaseKey) {
                console.error("Cannot undo pick: Missing Firebase key");
                showNotification("Error: Cannot undo pick due to missing data.");
                return;
            }

            // Convert parameters to ensure correct types
            pickNumberToUndo = parseInt(pickNumberToUndo) || 0;
            roundToRestore = parseInt(roundToRestore) || 1;

            // Verify it's actually the last pick that was made overall
            const actualLastPickNumber = draftedPlayers.length; // Since pick numbers start at 1
            if (pickNumberToUndo !== actualLastPickNumber) {
                console.warn(`Undo attempt on pick #${pickNumberToUndo}, but last pick was #${actualLastPickNumber}. Aborting.`);
                showNotification(`Cannot undo pick #${pickNumberToUndo}. Only the very last pick (#${actualLastPickNumber}) can be undone.`);
                return; // Prevent undoing historical picks
            }

            const name = playerNameForMessage || 'last player';
            const teamName = teamNameToRestore || 'the previous team';

            if (!confirm(`Are you sure you want to UNDO the last pick (#${pickNumberToUndo} - ${name} by ${teamName})? This will revert the draft to Pick #${pickNumberToUndo} (Round ${roundToRestore}, ${teamName}'s turn).`)) {
                return;
            }

            console.log(`Commissioner undoing pick #${pickNumberToUndo} (Key: ${firebaseKey})`);

            // Prepare atomic update
            const updates = {};
            updates[`leagues/${leagueId}/draftedPlayers/${firebaseKey}`] = null; // Remove player
            updates[`leagues/${leagueId}/draftStatus/currentDrafter`] = teamUidToRestore; // Revert drafter
            updates[`leagues/${leagueId}/draftStatus/pickNumber`] = pickNumberToUndo; // Revert pick number
            updates[`leagues/${leagueId}/draftStatus/round`] = roundToRestore; // Revert round

            // Execute atomic update
            const dbRef = ref(database);
            update(dbRef, updates).then(() => {
                console.log(`Pick #${pickNumberToUndo} (${name}) undone successfully.`);
                showNotification(`Pick #${pickNumberToUndo} (${name}) undone. It's now ${teamName}'s turn.`);
                addChatMessage({
                    type: 'system',
                    text: `${currentUser.displayName} (Commish) undid the last pick (#${pickNumberToUndo} - ${name}). Reverted to Pick #${pickNumberToUndo} (${teamName}'s turn).`,
                    timestamp: serverTimestamp()
                });
                // Data updates via onValue listener will refresh UI
            }).catch(error => {
                console.error(`Error undoing pick #${pickNumberToUndo} (Key: ${firebaseKey}):`, error);
                showNotification(`Error undoing pick: ${error.message}`, 7000);
            });
        }

        // Refresh button functionality
        document.getElementById('refresh-players-btn').addEventListener('click', function() {
            // Clear existing player data to force reload
            allPlayers = [];
            
            // Show loading indicator in the player table
            if(playerTableBody) {
                playerTableBody.innerHTML = `<tr><td colspan="10" style="text-align: center;"><div class="loader"></div></td></tr>`;
            }
            
            // Show notification
            showNotification("Refreshing player data...");
            
            // Load player data
            loadPlayerData();
        });
        // --- Draft Queue Functions ---
        
        // Function to add "Add to Queue" buttons to player rows
        function addQueueButtonsToPlayerRows() {
            // Count unprocessed rows
            const unprocessedRows = document.querySelectorAll('#playerTableBody tr:not([data-queue-processed])');
            if (unprocessedRows.length === 0) return; // No work to do
            
            // Find all table rows in the player table body that need processing
            const playerRows = document.querySelectorAll('#playerTableBody tr:not([data-queue-processed])');
            
            let processedCount = 0;
            playerRows.forEach(row => {
                // Find the action cell (last cell)
                const cells = row.querySelectorAll('td');
                if (cells.length === 0) {
                    row.setAttribute('data-queue-processed', 'true'); // Mark non-data rows as processed
                    return;
                }
                
                const actionCell = cells[cells.length - 1];
                const draftButton = actionCell.querySelector('.draft-button');
                
                // Skip if no draft button found
                if (!draftButton) {
                    row.setAttribute('data-queue-processed', 'true'); // Mark unusable rows as processed
                    return;
                }
                
                // Skip if a queue button already exists
                if (actionCell.querySelector('.add-to-queue')) {
                    row.setAttribute('data-queue-processed', 'true'); // Already has a button
                    return;
                }
                
                // Create Add to Queue button
                const queueButton = document.createElement('button');
                queueButton.className = 'add-to-queue';
                queueButton.textContent = 'Add to Queue';
                
                // Find the player data
                const playerId = row.getAttribute('data-player-id') || row.getAttribute('data-id');
                if (!playerId) {
                    row.setAttribute('data-queue-processed', 'true'); // No player ID, mark as processed
                    return;
                }
                
                // Add click event listener
                queueButton.addEventListener('click', function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                    
                    // Find the player data
                    let player = null;
                    
                    // Try to find player by ID
                    if (allPlayers) {
                        player = allPlayers.find(p => p.id === playerId || p.id.toString() === playerId);
                    }
                    
                    // If no player found, create a basic player object from the row data
                    if (!player) {
                        const nameCell = cells[0];
                        const posCell = cells[1];
                        const teamCell = cells[2];
                        
                        player = {
                            id: playerId,
                            fullName: nameCell.textContent.trim(),
                            position: posCell ? posCell.textContent.trim() : '',
                            teamAbbreviation: teamCell ? teamCell.textContent.trim() : ''
                        };
                        
                        // Try to get stats if available
                        if (cells.length > 4) {
                            player.goals = parseInt(cells[4].textContent) || 0;
                            player.assists = parseInt(cells[5].textContent) || 0;
                            player.points = parseInt(cells[6].textContent) || 0;
                        }
                        if (cells.length > 7) {
                            player.wins = parseInt(cells[7].textContent) || 0;
                            player.shutouts = parseInt(cells[8].textContent) || 0;
                        }
                    }
                    
                    // Add player to queue
                    if (player && player.id) {
                        addToQueue(player);
                    }
                    
                    return false;
                });
                
                // Insert the queue button before the draft button
                actionCell.insertBefore(queueButton, draftButton);
                
                // Mark row as processed
                row.setAttribute('data-queue-processed', 'true');
                processedCount++;
            });
        }
        
        // Load the user's draft queue from Firebase
        function loadDraftQueue() {
            if (!currentUser || !leagueId) return;
            
            // Clean up any existing listener
            if (draftQueueListener) {
                try {
                    const oldQueueRef = ref(database, `leagues/${leagueId}/draftQueues/${currentUser.uid}`);
                    off(oldQueueRef, 'value', draftQueueListener);
                } catch (e) {
                    console.error("Error removing old queue listener:", e);
                }
                draftQueueListener = null;
            }
            
            const queueRef = ref(database, `leagues/${leagueId}/draftQueues/${currentUser.uid}`);
            draftQueueListener = onValue(queueRef, (snapshot) => {
                if (snapshot.exists()) {
                    const queueData = snapshot.val();
                    myDraftQueue = Array.isArray(queueData) ? queueData : [];
                } else {
                    myDraftQueue = [];
                }
                
                renderDraftQueue();
            }, (error) => {
                console.error("Error loading draft queue:", error);
            });
            
            console.log("Draft queue listener added");
        }
        
        // Save the draft queue to Firebase
        function saveDraftQueue() {
            if (!currentUser || !leagueId) return;
            
            const queueRef = ref(database, `leagues/${leagueId}/draftQueues/${currentUser.uid}`);
            set(queueRef, myDraftQueue)
                .then(() => {
                    console.log("Draft queue saved successfully");
                })
                .catch((error) => {
                    console.error("Error saving draft queue:", error);
                    showNotification("Error saving your draft queue", 5000);
                });
        }
        
        // Add a player to the draft queue
        function addToQueue(player) {
            // Check if player is already in queue
            const existingIndex = myDraftQueue.findIndex(p => p.id === player.id);
            if (existingIndex >= 0) {
                showNotification("Player is already in your draft queue", 3000);
                return;
            }
            
            // Create a simplified player object for the queue
            const queuePlayer = {
                id: player.id,
                fullName: player.fullName,
                position: player.position,
                teamAbbreviation: player.teamAbbreviation || player.teamId,
                goals: player.goals || 0,
                assists: player.assists || 0,
                points: player.points || 0,
                wins: player.wins || 0,
                shutouts: player.shutouts || 0
            };
            
            // Add player to queue
            myDraftQueue.push(queuePlayer);
            
            // Save to Firebase
            saveDraftQueue();
            
            showNotification(`${player.fullName} added to your draft queue`, 2000);
        }
        
        // Remove a player from the draft queue
        function removeFromQueue(playerId) {
            const initialLength = myDraftQueue.length;
            myDraftQueue = myDraftQueue.filter(player => player.id !== playerId);
            
            if (myDraftQueue.length < initialLength) {
                // Save to Firebase
                saveDraftQueue();
                
                showNotification("Player removed from your draft queue", 2000);
            }
        }
        
        // Render the draft queue in the UI
        function renderDraftQueue() {
            if (!draftQueueList) return;
            
            // Clear existing items
            draftQueueList.innerHTML = '';
            
            if (myDraftQueue.length === 0) {
                // Show empty message
                if (emptyQueueMessage) emptyQueueMessage.classList.remove('hidden');
                return;
            }
            
            // Hide empty message
            if (emptyQueueMessage) emptyQueueMessage.classList.add('hidden');
            
            // Add each player to the list
            myDraftQueue.forEach((player, index) => {
                const queueItem = document.createElement('li');
                queueItem.className = 'queue-item';
                queueItem.setAttribute('data-player-id', player.id);
                queueItem.draggable = true;
                
                // Position-specific stats
                let statsHtml = '';
                if (player.position === 'G') {
                    statsHtml = `W: ${player.wins || 0}, SO: ${player.shutouts || 0}`;
                } else {
                    statsHtml = `G: ${player.goals || 0}, A: ${player.assists || 0}, PTS: ${player.points || 0}`;
                }
                
                queueItem.innerHTML = `
                    <div class="queue-item-info">
                        <span class="queue-item-rank">${index + 1}</span>
                        <div>
                            <div class="queue-item-name">${player.fullName}</div>
                            <div class="queue-item-details">
                                ${player.position} | ${player.teamAbbreviation} | ${statsHtml}
                            </div>
                        </div>
                    </div>
                    <div class="queue-item-actions">
                        <div class="queue-item-move-buttons">
                            <button class="move-up-button" title="Move Up" ${index === 0 ? 'disabled' : ''}>&uarr;</button>
                            <button class="move-down-button" title="Move Down" ${index === myDraftQueue.length - 1 ? 'disabled' : ''}>&darr;</button>
                        </div>
                        <button class="draft-queue-button" title="Draft this player">Draft</button>
                        <button class="remove-from-queue" data-player-id="${player.id}">Remove</button>
                    </div>
                `;
                
                // Add drag event listeners
                queueItem.addEventListener('dragstart', handleQueueDragStart);
                queueItem.addEventListener('dragend', handleQueueDragEnd);
                queueItem.addEventListener('dragover', handleQueueDragOver);
                queueItem.addEventListener('dragenter', handleQueueDragEnter);
                queueItem.addEventListener('dragleave', handleQueueDragLeave);
                queueItem.addEventListener('drop', handleQueueDrop);
                
                // Add click event to select player in main list - clicking on name or details
                queueItem.querySelector('.queue-item-info').addEventListener('click', function(event) {
                    highlightPlayerInAvailableList(player);
                });
                
                // Add click event for draft button
                const draftBtn = queueItem.querySelector('.draft-queue-button');
                if (draftBtn) {
                    draftBtn.addEventListener('click', function() {
                        // Select this player in the available list and attempt to draft them
                        const success = draftPlayerFromQueue(player);
                        if (!success) {
                            showNotification("Unable to draft this player - they may already be drafted or unavailable", 3000);
                        }
                    });
                }
                
                // Add click event for remove button
                const removeBtn = queueItem.querySelector('.remove-from-queue');
                if (removeBtn) {
                    removeBtn.addEventListener('click', function() {
                        removeFromQueue(player.id);
                    });
                }
                
                // Add click events for move up/down buttons
                const moveUpBtn = queueItem.querySelector('.move-up-button');
                if (moveUpBtn) {
                    moveUpBtn.addEventListener('click', function() {
                        if (index > 0) {
                            // Move player up in the queue
                            const [movedPlayer] = myDraftQueue.splice(index, 1);
                            myDraftQueue.splice(index - 1, 0, movedPlayer);
                            saveDraftQueue();
                            renderDraftQueue();
                        }
                    });
                }
                
                const moveDownBtn = queueItem.querySelector('.move-down-button');
                if (moveDownBtn) {
                    moveDownBtn.addEventListener('click', function() {
                        if (index < myDraftQueue.length - 1) {
                            // Move player down in the queue
                            const [movedPlayer] = myDraftQueue.splice(index, 1);
                            myDraftQueue.splice(index + 1, 0, movedPlayer);
                            saveDraftQueue();
                            renderDraftQueue();
                        }
                    });
                }
                
                draftQueueList.appendChild(queueItem);
            });
        }
        
        // Helper function to find the closest drop target based on mouse position
        function getClosestDropTarget(mouseY) {
            const items = document.querySelectorAll('.queue-item');
            if (items.length === 0) return null;
            
            let closestElement = null;
            let closestDistance = Infinity;
            let position = 'after'; // 'before' or 'after'
            
            items.forEach(item => {
                const rect = item.getBoundingClientRect();
                const topDistance = Math.abs(mouseY - rect.top);
                const bottomDistance = Math.abs(mouseY - rect.bottom);
                
                if (topDistance < closestDistance) {
                    closestDistance = topDistance;
                    closestElement = item;
                    position = 'before';
                }
                
                if (bottomDistance < closestDistance) {
                    closestDistance = bottomDistance;
                    closestElement = item;
                    position = 'after';
                }
            });
            
            return closestElement ? { element: closestElement, position } : null;
        }
        
        // Update the drop indicator position
        function updateDropIndicator(element, position) {
            const indicator = document.querySelector('.drop-indicator');
            if (!indicator) return;
            
            const rect = element.getBoundingClientRect();
            const listRect = draftQueueList.getBoundingClientRect();
            
            indicator.style.display = 'block';
            indicator.style.width = `${element.offsetWidth}px`;
            
            if (position === 'before') {
                indicator.style.top = `${rect.top - listRect.top - 2}px`;
            } else { // position === 'after'
                indicator.style.top = `${rect.bottom - listRect.top - 2}px`;
            }
        }
        
        // Hide the drop indicator
        function hideDropIndicator() {
            const indicator = document.querySelector('.drop-indicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }
        
        // Revert to a simpler drag-and-drop implementation that works more reliably
        function handleQueueDragStart(e) {
            // Mark this element as the one being dragged
            this.classList.add('dragging');
            
            // Store the player ID in the dataTransfer
            e.dataTransfer.setData('text/plain', this.getAttribute('data-player-id'));
            
            // Set effectAllowed to move
            e.dataTransfer.effectAllowed = 'move';
            
            console.log('Started dragging player:', this.getAttribute('data-player-id'));
        }
        
        function handleQueueDragEnd(e) {
            // Remove the dragging class
            this.classList.remove('dragging');
            
            // Clean up any over classes
            document.querySelectorAll('.queue-item').forEach(item => {
                item.classList.remove('over');
            });
            
            console.log('Ended drag operation');
        }
        
        function handleQueueDragOver(e) {
            // This is necessary to allow dropping
            e.preventDefault();
            
            // Set the drop effect to move
            e.dataTransfer.dropEffect = 'move';
            
            // Add over class to the queue item
            this.classList.add('over');
            
            return false;
        }
        
        function handleQueueDragEnter(e) {
            // Highlight potential drop target
            this.classList.add('over');
        }
        
        function handleQueueDragLeave(e) {
            // Remove highlight
            this.classList.remove('over');
        }
        
        function handleQueueDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Remove highlight
            this.classList.remove('over');
            
            try {
                // Get the dragged player ID from dataTransfer
                const draggedPlayerId = e.dataTransfer.getData('text/plain');
                if (!draggedPlayerId) {
                    console.error('No player ID found in drop data');
                    return false;
                }
                
                const dropTarget = this;
                const targetPlayerId = dropTarget.getAttribute('data-player-id');
                
                console.log('Dropping player', draggedPlayerId, 'onto', targetPlayerId);
                
                // Don't do anything if dropping on the same item
                if (draggedPlayerId === targetPlayerId) {
                    console.log('Same player, ignoring drop');
                    return false;
                }
                
                // Find the indices of the dragged and target items
                const draggedIndex = myDraftQueue.findIndex(p => p.id === draggedPlayerId);
                const targetIndex = myDraftQueue.findIndex(p => p.id === targetPlayerId);
                
                console.log('Found indices:', draggedIndex, targetIndex);
                
                if (draggedIndex !== -1 && targetIndex !== -1) {
                    // Reorder the array - insert before the target
                    const [removedItem] = myDraftQueue.splice(draggedIndex, 1);
                    myDraftQueue.splice(targetIndex, 0, removedItem);
                    
                    console.log('Reordered queue:', myDraftQueue.map(p => p.fullName));
                    
                    // Save to Firebase
                    saveDraftQueue();
                    
                    // Render the updated queue
                    renderDraftQueue();
                    
                    console.log('Queue updated after drop');
                } else {
                    console.error('Could not find indices for drag and drop operation');
                }
            } catch (error) {
                console.error('Error in drop handler:', error);
            }
            
            return false;
        }
        
        // Find and highlight a player in the main table
        function highlightPlayerInAvailableList(player) {
            // First try to find by data-player-id attribute
            let playerRows = document.querySelectorAll('#playerTableBody tr');
            let playerFound = false;
            
            // Try to find the player by ID
            playerRows.forEach(row => {
                const id = row.getAttribute('data-player-id') || row.getAttribute('data-id');
                if (id === player.id || id === player.id.toString()) {
                    // Highlight the row
                    playerRows.forEach(r => r.classList.remove('selected-player'));
                    row.classList.add('selected-player');
                    
                    // Scroll to the player
                    row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    playerFound = true;
                }
            });
            
            // If not found by ID, try to find by player name (as fallback)
            if (!playerFound) {
                playerRows.forEach(row => {
                    const nameCell = row.querySelector('td:first-child');
                    if (nameCell && nameCell.textContent.trim() === player.fullName) {
                        // Highlight the row
                        playerRows.forEach(r => r.classList.remove('selected-player'));
                        row.classList.add('selected-player');
                        
                        // Scroll to the player
                        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        playerFound = true;
                    }
                });
            }
            
            if (!playerFound) {
                showNotification("Player not found in available players list - they may have been drafted already", 3000);
            }
            
            return playerFound;
        }
        
        // Draft a player from the queue
        function draftPlayerFromQueue(player) {
            // First try to find and highlight the player
            const playerFound = highlightPlayerInAvailableList(player);
            if (!playerFound) {
                return false;
            }
            
            // Get the selected player row
            const selectedRow = document.querySelector('#playerTableBody tr.selected-player');
            if (!selectedRow) {
                return false;
            }
            
            // Find the draft button in the row
            const draftButton = selectedRow.querySelector('.draft-button');
            if (!draftButton) {
                return false;
            }
            
            // Check if button is disabled
            if (draftButton.disabled) {
                return false;
            }
            
            // Click the draft button
            draftButton.click();
            return true;
        }
        
        // Clear the draft queue when round is concluded
        function clearDraftQueue() {
            if (!currentUser || !leagueId) return;
            
            myDraftQueue = [];
            saveDraftQueue();
            renderDraftQueue();
        }
        
        // We need to make sure these functions are only modified once
        if (typeof originalCleanupListeners === 'undefined') {
            // Update cleanupListeners to include draft queue listener
            const originalCleanupListeners = cleanupListeners;
            cleanupListeners = function() {
                originalCleanupListeners();
                
                // Clean up draft queue listener
                if (draftQueueListener && leagueId && currentUser) {
                    try {
                        const queueRef = ref(database, `leagues/${leagueId}/draftQueues/${currentUser.uid}`);
                        off(queueRef, 'value', draftQueueListener);
                        console.log(" - Unsubscribed from draft queue listener.");
                    } catch (e) { 
                        console.error("Error unsubscribing draft queue listener:", e); 
                    }
                    draftQueueListener = null;
                }
            };
        }
        
        if (typeof originalSetupLeagueListeners === 'undefined') {
            // Add to setupLeagueListeners to load draft queue
            const originalSetupLeagueListeners = setupLeagueListeners;
            setupLeagueListeners = function() {
                originalSetupLeagueListeners();
                
                // Load draft queue
                loadDraftQueue();
            };
        }
        
        // Add observers to add queue buttons when the player table is updated
        // This ensures our queue buttons are added regardless of how the player table is rendered
        function setupQueueButtonObservers() {
            // Flag to prevent multiple simultaneous calls
            let isProcessing = false;
            
            // Set up a debounced version of addQueueButtonsToPlayerRows
            const debouncedAddButtons = function() {
                if (isProcessing) return;
                isProcessing = true;
                
                // Use setTimeout to ensure this runs after current stack is clear
                setTimeout(() => {
                    addQueueButtonsToPlayerRows();
                    isProcessing = false;
                }, 300);
            };
            
            // Function to be called when player table body changes
            const mutationCallback = function(mutationsList, observer) {
                // Only process if we have meaningful changes
                let shouldProcess = false;
                
                for (const mutation of mutationsList) {
                    if (mutation.type === 'childList' && 
                        (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
                        shouldProcess = true;
                        break;
                    }
                }
                
                if (shouldProcess) {
                    debouncedAddButtons();
                }
            };
            
            // Create observer for the player table body
            const tableObserver = new MutationObserver(mutationCallback);
            
            // Start observing the player table body for DOM changes
            const playerTableBody = document.getElementById('playerTableBody');
            if (playerTableBody) {
                tableObserver.observe(playerTableBody, { childList: true, subtree: false });
            }
            
            // Also call it immediately in case table is already populated
            debouncedAddButtons();
            
            // Periodically check once every few seconds just in case
            const intervalCheck = setInterval(() => {
                const rows = document.querySelectorAll('#playerTableBody tr:not([data-queue-processed])');
                if (rows.length > 0) {
                    debouncedAddButtons();
                }
            }, 5000);
            
            // Clean up interval when page unloads
            window.addEventListener('beforeunload', () => {
                clearInterval(intervalCheck);
            });
        }
        
        // Call the setup function when the document is ready
        document.addEventListener('DOMContentLoaded', setupQueueButtonObservers);
        
        // Also call it after authentication in case DOMContentLoaded already fired
        if (typeof originalSetupLeagueListeners === 'undefined') {
            const oldSetupLeagueListeners = setupLeagueListeners;
            setupLeagueListeners = function() {
                oldSetupLeagueListeners();
                
                // Load draft queue
                loadDraftQueue();
                
                // Set up observers for queue buttons
                setTimeout(setupQueueButtonObservers, 500);
            };
        }
        
        // Add CSS for the draft queue
        const queueStyles = document.createElement('style');
        queueStyles.textContent = `
            .my-draft-queue-section {
                margin-bottom: 1.5rem;
            }
            
            .queue-instructions {
                font-size: 0.9rem;
                color: #666;
                margin-bottom: 1rem;
            }
            
            .queue-container {
                border: 1px solid var(--border-color);
                border-radius: 0.25rem;
                background-color: #fff;
                padding: 0.5rem;
                max-height: 300px;
                overflow-y: auto;
            }
            
            .draft-queue-list {
                list-style: none;
                padding: 0;
                margin: 0;
            }
            
            .queue-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0.75rem;
                margin-bottom: 0.5rem;
                background-color: #f8f9fa;
                border: 1px solid #e9ecef;
                border-radius: 0.25rem;
                cursor: grab;
            }
            
            .queue-item:hover {
                background-color: #e9ecef;
            }
            
            .queue-item.dragging {
                opacity: 0.5;
                cursor: grabbing;
                background-color: #e8f4ff;
                transform: scale(1.02);
                box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
                position: relative;
                z-index: 10;
            }
            
            .queue-item.over {
                border: 2px dashed var(--primary-color);
                padding: calc(0.75rem - 1px);
                background-color: #f0f8ff;
            }
            
            .queue-item-actions {
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .draft-queue-button {
                background-color: var(--primary-color);
                color: white;
                border: none;
                border-radius: 0.25rem;
                padding: 0.25rem 0.5rem;
                font-size: 0.8rem;
                cursor: pointer;
            }
            
            .draft-queue-button:hover {
                background-color: var(--secondary-color);
            }
            
            .queue-item-move-buttons {
                display: flex;
                flex-direction: column;
                gap: 2px;
            }
            
            .move-up-button, 
            .move-down-button {
                background-color: #6c757d;
                color: white;
                border: none;
                border-radius: 3px;
                width: 24px;
                height: 20px;
                font-size: 12px;
                padding: 0;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .move-up-button:hover,
            .move-down-button:hover {
                background-color: #5a6268;
            }
            
            .move-up-button:disabled,
            .move-down-button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }
            
            /* Drop indicator for drag and drop */
            .drop-indicator {
                display: none;
                position: absolute;
                left: 0;
                height: 4px;
                background-color: var(--primary-color);
                z-index: 100;
                border-radius: 2px;
                pointer-events: none;
            }
            
            .queue-item-info {
                flex-grow: 1;
                display: flex;
                align-items: center;
            }
            
            .queue-item-name {
                font-weight: bold;
                margin-bottom: 0.25rem;
            }
            
            .queue-item-details {
                font-size: 0.85rem;
                color: #6c757d;
            }
            
            .queue-item-rank {
                background-color: var(--primary-color);
                color: white;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                font-size: 0.8rem;
                font-weight: bold;
                margin-right: 0.75rem;
                flex-shrink: 0;
            }
            
            .remove-from-queue {
                background-color: #dc3545;
                color: white;
                border: none;
                border-radius: 0.25rem;
                padding: 0.25rem 0.5rem;
                font-size: 0.8rem;
                cursor: pointer;
            }
            
            .remove-from-queue:hover {
                background-color: #c82333;
            }
            
            .add-to-queue {
                background-color: #6c757d;
                color: white;
                border: none;
                border-radius: 0.25rem;
                padding: 0.25rem 0.5rem;
                font-size: 0.8rem;
                margin-right: 0.5rem;
                cursor: pointer;
            }
            
            .add-to-queue:hover {
                background-color: #5a6268;
            }
            
            .selected-player {
                background-color: #e8f4ff !important;
                border-left: 3px solid var(--primary-color) !important;
            }
        `;
        document.head.appendChild(queueStyles);
        
        // We don't need to modify createPlayerRow as it doesn't exist
        // We'll use the addQueueButtonsToPlayerRows function instead
        
        // Modify handleConcludeRound to clear draft queues
        if (typeof originalHandleConcludeRound === 'undefined') {
            const originalHandleConcludeRound = handleConcludeRound;
            handleConcludeRound = function() {
                const result = originalHandleConcludeRound.apply(this, arguments);
                
                // Clear draft queue when round is concluded
                clearDraftQueue();
                
                return result;
            };
        }
        
        // Modify handleSaveDraftOrder to clear all draft queues for all users
        if (typeof originalHandleSaveDraftOrder === 'undefined') {
            const originalHandleSaveDraftOrder = handleSaveDraftOrder || function() {};
            handleSaveDraftOrder = function() {
                const result = originalHandleSaveDraftOrder.apply(this, arguments);
                
                // Clear all draft queues for all users when moving to next round
                if (leagueId) {
                    const queuesRef = ref(database, `leagues/${leagueId}/draftQueues`);
                    set(queuesRef, null)
                        .then(() => {
                            console.log("All draft queues cleared for next round");
                        })
                        .catch((error) => {
                            console.error("Error clearing draft queues:", error);
                        });
                }
                
                return result;
            };
        }
    </script>
</body>

</html>